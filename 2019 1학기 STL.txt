//
//
//
//

#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>
#include <iterator>

//using namespace std;

void save(std::string);

int main()
{
	save("main.cpp");
}

void save(std::string name)
{
	// name을 읽기 모드로 오픈한다
	std::ifstream in(name);

	// 기록할 파일 쓰기모드로 오픈한다.(덧붙여 쓰기 모드)
	std::ofstream out("2019 1학기 STL.txt", std::ios::app);


	// 모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>(), std::ostreambuf_iterator<char>(out));

	// 저장한 시간도 기록한다.


}//
//
//
//

#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>
#include <iterator>

//using namespace std;

void save(std::string);

int main()
{
	save("main.cpp");
}

void save(std::string name)
{
	// name을 읽기 모드로 오픈한다
	std::ifstream in(name);

	// 기록할 파일 쓰기모드로 오픈한다.(덧붙여 쓰기 모드)
	std::ofstream out("2019 1학기 STL.txt", std::ios::app);


	// 모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>(), std::ostreambuf_iterator<char>(out));

	// 저장한 시간도 기록한다.


}//
//
//
//

#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>
#include <iterator>

//using namespace std;

void save(std::string);

int main()
{
	save("main.cpp");
}

void save(std::string name)
{
	// name을 읽기 모드로 오픈한다
	std::ifstream in(name);

	// 기록할 파일 쓰기모드로 오픈한다.(덧붙여 쓰기 모드)
	std::ofstream out("2019 1학기 STL.txt", std::ios::app);


	// 모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>(), std::ostreambuf_iterator<char>(out));

	// 저장한 시간도 기록한다.


}

----------------------------------------------
 Thu Mar  7 17:56:23 2019
----------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <algorithm>
#include <iterator>
#include <chrono>

//using namespace std;

void save(std::string);

int main()
{
	save("main.cpp");
}

void save(std::string name)
{
	
	// name을 읽기 모드로 오픈한다
	std::ifstream in(name);


	// 기록할 파일 쓰기모드로 오픈한다.(덧붙여 쓰기 모드)
	std::ofstream out("2019 1학기 STL.txt", std::ios::app);

	//오늘 시간을 string에 저장해보자
	auto now = std::chrono::system_clock::now();
	auto date = std::chrono::system_clock::to_time_t(now);
	std::string time (ctime(&date));

	// 저장한 시간도 기록한다.
	out << std::endl << std::endl;
	out << "----------------------------------------------" << std::endl;
	out << ' ' << time;
	out << "----------------------------------------------" << std::endl;
	// 모든 내용을 읽어서 쓴다.
	std::copy(std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>(), std::ostreambuf_iterator<char>(out));


	
}



----------------------------------------------
 Thu Mar  7 18:00:27 2019
----------------------------------------------
#include <iostream>
#include "Save.h"


int main()
{
	save("main.cpp");
}






===============
 Thu Mar  7 18:31:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;

int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(begin(a), end(a));

	save("main.cpp");
}






===============
 Thu Mar  7 18:32:22 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;

int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(begin(a), end(a));

	for (int i = 0; i < 10; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:33:17 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;

int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(begin(a), end(a));

	for (int d:a )
	{
		cout << d << " ";
	}
	cout << endl;

	save("main.cpp");
}






===============
 Thu Mar  7 18:38:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;

bool how(int a, int b)
{
	return a > b;
}
int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(begin(a), end(a), how);

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:38:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;

bool how(int a, int b)
{
	return a > b;
}
int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(&a[0], &a[10], how);

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:42:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include "Save.h"
using namespace std;


int main()
{
	int a[] {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}; //초기화자목록 이니셜라이저

	//오름차순으로 정렬한다.
	sort(begin(a), end(a), [](int a, int b)
	{
		return a > b;
	}
	);

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:49:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;


int main()
{
	int a[10000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid;
	for (int i = 0; i < 10000; ++i)
	{
		a[i] = uid(dre);
	}
	

	sort(begin(a), end(a));
	

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:52:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;


int main()
{
	int a[10000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid;
	for (int i = 0; i < 10000; ++i)
	{
		a[i] = uid(dre);
	}
	

	sort(begin(a), end(a));
	

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Thu Mar  7 18:52:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/7
// - 자료를 파일에 저장해 보기
// - 랜덤 정수를 만들기
// - 정수를 정렬하기
// - 정렬한 결과를 파일에 저장하기
// - 파일에 저장한 정수를 읽어 화면에 출력하기
// - 책 내용은 다음 주 부터
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;


int main()
{
	int a[10000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,100000);
	for (int i = 0; i < 10000; ++i)
	{
		a[i] = uid(dre);
	}
	

	sort(begin(a), end(a));
	

	for (int d:a )
	{
		cout << d << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:47:41 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,10'0000);
	for (int& d:a)
	{
		d = uid(dre);
	}
	
	
	sort(begin(a), end(a));
	
	//정렬 후 앞에서 100개만 출력
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:54:02 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	int* a = new int[100'0000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,100'0000);
	for (int i=0;i<100'000;++i)
	{
		a[i] = uid(dre);
	}
	
	
	sort(a, a + 100'0000);
	
	//정렬 후 앞에서 100개만 출력
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:54:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	int* a = new int[100'0000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,100'0000);
	for (int i = 0; i < 100'000; ++i)
	{
		a[i] = uid(dre);
	}
	
	
	sort(a, a + 100'0000);
	
	//정렬 후 앞에서 100개만 출력
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:55:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	int* a = new int[100'0000];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,100'0000);

	for (int i = 0; i < 100'0000; ++i)
	{
		a[i] = uid(dre);
	}
	
	
	sort(a, a + 100'0000);
	
	//정렬 후 앞에서 100개만 출력
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:59:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	cout << "동적으로 할당할 정수의 갯수:";
	int num;
	cin >> num;
	
	a = new int[num];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,100'0000);

	for (int i = 0; i < num; ++i)
	{
		a[i] = uid(dre);
	}
	
	//정렬 전 앞에서 백개
	cout << "정렬 전 앞에서 백개" << endl;
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	cout << endl;
	
	sort(a, a + num);
	
	//정렬 후 앞에서 100개
	cout << "정렬 후 앞에서 백개" << endl;
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 17:59:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	cout << "동적으로 할당할 정수의 갯수:";
	int num;
	cin >> num;
	
	a = new int[num];
	
	//오름차순으로 정렬한다.

	//10000개를 임의의 값으로 채워넣자
	default_random_engine dre;
	uniform_int_distribution<int> uid(0,1'0000);

	for (int i = 0; i < num; ++i)
	{
		a[i] = uid(dre);
	}
	
	//정렬 전 앞에서 백개
	cout << "정렬 전 앞에서 백개" << endl;
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	cout << endl;
	
	sort(a, a + num);
	
	//정렬 후 앞에서 100개
	cout << "정렬 후 앞에서 백개" << endl;
	for (int i = 0; i < 100; ++i)
	{
		cout << a[i] << " ";
	}

	save("main.cpp");
}






===============
 Tue Mar 12 18:00:25 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	{
		cout << "동적으로 할당할 정수의 갯수:";
		int num;
		cin >> num;

		a = new int[num];

		//오름차순으로 정렬한다.

		//10000개를 임의의 값으로 채워넣자
		default_random_engine dre;
		uniform_int_distribution<int> uid(0, 1'0000);

		for (int i = 0; i < num; ++i)
		{
			a[i] = uid(dre);
		}

		//정렬 전 앞에서 백개
		cout << "정렬 전 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

		cout << endl;

		sort(a, a + num);

		//정렬 후 앞에서 100개
		cout << "정렬 후 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

	}

	save("main.cpp");
}






===============
 Tue Mar 12 18:01:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	save("main.cpp");
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	while (true)
	{
		cout << "동적으로 할당할 정수의 갯수:";
		int num;
		cin >> num;

		a = new int[num];

		//오름차순으로 정렬한다.

		//10000개를 임의의 값으로 채워넣자
		default_random_engine dre;
		uniform_int_distribution<int> uid(0, 1'0000);

		for (int i = 0; i < num; ++i)
		{
			a[i] = uid(dre);
		}

		//정렬 전 앞에서 백개
		cout << "정렬 전 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

		cout << endl;

		sort(a, a + num);

		//정렬 후 앞에서 100개
		cout << "정렬 후 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

	}
	

	
}






===============
 Tue Mar 12 18:01:13 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	save("main.cpp");
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	while (true)
	{
		cout << "동적으로 할당할 정수의 갯수:";
		int num;
		cin >> num;

		a = new int[num];

		//오름차순으로 정렬한다.

		//10000개를 임의의 값으로 채워넣자
		default_random_engine dre;
		uniform_int_distribution<int> uid(0, 1'0000);

		for (int i = 0; i < num; ++i)
		{
			a[i] = uid(dre);
		}

		//정렬 전 앞에서 백개
		cout << "정렬 전 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

		cout << endl;

		sort(a, a + num);

		//정렬 후 앞에서 100개
		cout << "정렬 후 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

	}
	

	
}






===============
 Tue Mar 12 18:05:55 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	save("main.cpp");
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	while (true)
	{
		cout << "동적으로 할당할 정수의 갯수:";
		int num;
		cin >> num;

		a = new int[num];

		//오름차순으로 정렬한다.

		//10000개를 임의의 값으로 채워넣자
		default_random_engine dre;
		uniform_int_distribution<int> uid(0, 1'0000);

		for (int i = 0; i < num; ++i)
		{
			a[i] = uid(dre);
		}

		//정렬 전 앞에서 백개
		cout << "정렬 전 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

		cout << endl;

		sort(a, a + num);

		//정렬 후 앞에서 100개
		cout << "정렬 후 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

	}
	

	
}






===============
 Tue Mar 12 18:06:04 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내욜을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <random>

#include "Save.h"
using namespace std;

// 정수 백만개를 전역변수로 만들었다.(100만개는 Data segment 에 위치한다)
// 실행파일에는 어떤 변화가 있는가


//int a[100'0000]; //구분자 존나오지네
//int a[100'0000]{ 1 };
//이 두가지 경우를 살펴볼 것

int a[100'0000];


int main()
{
	save("main.cpp");
	//사용자가 입력한 수 만큼 정수를 확보하고 랜덤값으로 초기화 정렬 후 출력
	int* a;
	
	while (true)
	{
		cout << "동적으로 할당할 정수의 갯수:";
		int num;
		cin >> num;

		a = new int[num];

		//오름차순으로 정렬한다.

		//10000개를 임의의 값으로 채워넣자
		default_random_engine dre;
		uniform_int_distribution<int> uid(0, 1'0000);

		for (int i = 0; i < num; ++i)
		{
			a[i] = uid(dre);
		}

		//정렬 전 앞에서 백개
		cout << "정렬 전 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

		cout << endl;

		sort(a, a + num);

		//정렬 후 앞에서 100개
		cout << "정렬 후 앞에서 백개" << endl;
		for (int i = 0; i < 100; ++i)
		{
			cout << a[i] << " ";
		}

	}
	

	
}






===============
 Tue Mar 12 18:19:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <algorithm>
#include <fstream>
#include "Save.h"
using namespace std;


// 정수 만개를 랜덤값으로 초기화 정렬 후 uid(dre) 0 ~ 10'0000
// "정수 만개오름차순.dat"에 저장하라

int main()
{
	//내가짠거
	int num = 10000;

	int* p = new int[num];

	uniform_int_distribution<> uid(0, 10'0000);
	default_random_engine dre;

	for (int i = 0; i < num; ++i)
	{
		p[i] = uid(dre);
	}

	sort(p, p + num);

	/*for (int i = 0; i < num; ++i)
	{
		cout << p[i] << endl;
	}*/

	ofstream out("정수 만개 오름차순.dat");

	for (int i = 0; i < num; ++i)
	{
		out << p[i] << " ";
	}
	out << endl;

	save("main.cpp");
}






===============
 Tue Mar 12 18:26:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <algorithm>
#include <fstream>
#include "Save.h"
using namespace std;


// 정수 만개를 랜덤값으로 초기화 정렬 후 uid(dre) 0 ~ 10'0000
// "정수 만개오름차순.dat"에 저장하라

int main()
{
	//내가쓴거
	int num = 10000;

	int* p = new int[num];

	uniform_int_distribution<> uid(0, 10'0000);
	default_random_engine dre(chrono::system_clock::now().time_since_epoch().count());

	for (int i = 0; i < num; ++i)
	{
		p[i] = uid(dre);
	}

	sort(p, p + num);

	/*for (int i = 0; i < num; ++i)
	{
		cout << p[i] << endl;
	}*/

	ofstream out("정수 만개 오름차순.dat");

	for (int i = 0; i < num; ++i)
	{
		out << p[i] << " ";
	}
	out << endl;

	save("main.cpp");
}






===============
 Tue Mar 12 18:31:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <algorithm>
#include <fstream>
#include "Save.h"
using namespace std;


// 정수 만개를 랜덤값으로 초기화 정렬 후 uid(dre) 0 ~ 10'0000
// "정수 만개오름차순.dat"에 저장하라

int main()
{
	int a[10000]{ 1 };

	uniform_int_distribution<> uid(0,1'0000);
	default_random_engine dre;

	for (int& d : a)
	{
		d = uid(dre);
	}

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat");
	for (int d : a)
	{
		out << d << ' ';
	}
	


	save("main.cpp");
}






===============
 Tue Mar 12 18:47:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <algorithm>
#include <fstream>
#include "Save.h"
using namespace std;


// 정수 만개를 랜덤값으로 초기화 정렬 후 uid(dre) 0 ~ 10'0000
// "정수 만개오름차순.dat"에 저장하라

//정수 10000개를 저장하려면 필요한 공간은 몇바이트인가? --> 40000바이트

//파일은 2가지 모드로 열 수 있다.
//default: text mode 또는 binary mode

int main()
{
	int a[10000];

	uniform_int_distribution<> uid;
	default_random_engine dre;

	for (int& d : a)
	{
		d = uid(dre);
	}

	sort(begin(a), end(a));

	ofstream out("정수만개오름차순.dat",ios::binary);
	out.write((const char*)a, 1'0000 * sizeof(int));

	


	save("main.cpp");
}






===============
 Tue Mar 12 18:50:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
using namespace std;


// 정수 만개를 랜덤값으로 초기화 정렬 후 uid(dre) 0 ~ 10'0000
// "정수 만개오름차순.dat"에 저장하라

//정수 10000개를 저장하려면 필요한 공간은 몇바이트인가? --> 40000바이트

//파일은 2가지 모드로 열 수 있다.
//default: text mode 또는 binary mode




// 파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어있다.
// 이 파일을 읽어서 화면에 출력하라
int main()
{
	

	save("main.cpp");
}






===============
 Tue Mar 12 19:01:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>
#include <iomanip>
#include "Save.h"
using namespace std;


// 파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어있다.
// 이 파일을 읽어서 화면에 출력하라
int main()
{
	ifstream in("정수만개오름차순.dat", ios::binary);
	int* a = new int[10000];

	in.read((char*)a,40000);

	for (int i = 0; i < 10000; ++i)
	{
		cout << setw(12) << a[i];
	}

	save("main.cpp");
}






===============
 Tue Mar 12 19:04:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
//
//
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include "Save.h"
using namespace std;

// Dog 천마리를 임의의 값으로 생성한다.
// 이름순으로 정렬하여 "개천마리.dat"에 저장
// 파일 크기를 확인한다.   sizeof(Dog)*1000
class Dog
{
	char name[11]; // 임의의 알파벳 10글자로 이름을 채우자
	int age;	   //(0,20)의 값으로 설정(uid dre)
};

// 파일 "정수만개오름차순.dat" 에는 정렬된 정수 만개가 바이너리로 저장되어있다.
// 이 파일을 읽어서 화면에 출력하라
int main()
{
	save("main.cpp");
}






===============
 Thu Mar 14 17:26:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <fstream>
#include <algorithm>
#include "Save.h"
using namespace std;


// Dog 천마리를 임의의 값으로 생성한다.
// 이름순으로 정렬하여 "개천마리.dat"에 저장
// 파일 크기를 확인한다.   sizeof(Dog)*1000
class Dog
{
private:
	char name[11]; // 임의의 알파벳 10글자로 이름을 채우자
	int age;	   //(0,20)의 값으로 설정(uid dre)

public:
	void setName(char p[])
	{
		for (int i = 0; i < 10; ++i)
		{
			name[i] = p[i];
		}

		name[11] = '\n';
	}

	char* getName()
	{
		return name;
	}

	void setAge(int pAge)
	{
		age = pAge;
	}

	int getAge()
	{
		return age;
	}
};

int main()
{
	Dog a[100] = {};

	uniform_int_distribution<int> nUid(97, 122);
	uniform_int_distribution<int> aUid(1, 20);
	default_random_engine dre;
	for (Dog& d : a)
	{
		char name[10]{};
		for (int i = 0; i < 10; ++i)
		{
			name[i] = nUid(dre);
		}
		d.setName(name);
		d.setAge(aUid(dre));
	}


	sort(begin(a), end(a),[](Dog b, Dog c)
	{
		char* tb = b.getName();
		char* tc = c.getName();

		for (int i = 0; i < 10; ++i)
		{
			if (tb[i] != tc[i])
			{
				if (tb[i] > tc[i])
				{
					return 0;
				}

				else
				{
					return 1;
				}
			}
		}
	}
	);

	for (Dog& d : a)
	{
		cout << d.getName() << " " << d.getAge() << endl;
	}

	//ofstream out("개천마리.dat", ios::app);

	//out.write(reinterpret_cast<char*> (a) , sizeof(Dog) * 1000);
	

	save("main.cpp");
}





===============
 Thu Mar 14 17:28:36 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <fstream>
#include <algorithm>
#include "Save.h"
using namespace std;


// Dog 천마리를 임의의 값으로 생성한다.
// 이름순으로 정렬하여 "개천마리.dat"에 저장
// 파일 크기를 확인한다.   sizeof(Dog)*1000
class Dog
{
private:
	char name[11]; // 임의의 알파벳 10글자로 이름을 채우자
	int age;	   //(0,20)의 값으로 설정(uid dre)

public:

	void setName(char p[])
	{
		for (int i = 0; i < 10; ++i)
		{
			name[i] = p[i];
		}

		name[11] = '\n';
	}

	char* getName()
	{
		return name;
	}

	void setAge(int pAge)
	{
		age = pAge;
	}

	int getAge()
	{
		return age;
	}
};

int main()
{
	Dog a[100] = {};

	uniform_int_distribution<int> nUid(97, 122);
	uniform_int_distribution<int> aUid(1, 20);
	default_random_engine dre;
	for (Dog& d : a)
	{
		char name[10]{};
		for (int i = 0; i < 10; ++i)
		{
			name[i] = nUid(dre);
		}
		d.setName(name);
		d.setAge(aUid(dre));
	}


	sort(begin(a), end(a),[](Dog b, Dog c)
	{
		char* tb = b.getName();
		char* tc = c.getName();

		for (int i = 0; i < 10; ++i)
		{
			if (tb[i] != tc[i])
			{
				if (tb[i] > tc[i])
				{
					return 0;
				}

				else
				{
					return 1;
				}
			}
		}
	}
	);

	for (Dog& d : a)
	{
		cout << d.getName() << " " << d.getAge() << endl;
	}

	//ofstream out("개천마리.dat", ios::app);

	//out.write(reinterpret_cast<char*> (a) , sizeof(Dog) * 1000);
	

	save("main.cpp");
}





===============
 Thu Mar 14 17:45:22 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include <fstream>
#include <algorithm>
#include <string>
#include "Save.h"
using namespace std;


// Dog 천마리를 임의의 값으로 생성한다.
// 이름순으로 정렬하여 "개천마리.dat"에 저장
// 파일 크기를 확인한다.   sizeof(Dog)*1000

uniform_int_distribution<> uid(0, 20);
default_random_engine dre;
uniform_int_distribution<> uidName('a', 'z');

class Dog
{
private:
	char name[11];
	int age;

public:
	Dog()
	{
		age = uid(dre);
		for (int i = 0; i < 10; ++i)
		{
			name[i] = uidName(dre);
		}
		name[10] = '\0';
	}

	string getName() const 
	{
		return string(name);
	}
};

Dog dogs[1000];

int main()
{
	sort(begin(dogs), end(dogs), [](const Dog& a, const Dog& b) -> bool
	{
		return a.getName() < b.getName();
	});

	ofstream out("개천마리.dat", ios::binary);
	out.write((char*)dogs, sizeof(Dog) * 1000);
	save("main.cpp");
}





===============
 Thu Mar 14 17:56:17 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>

#include "Save.h"
using namespace std;

class Dog
{
private:
	char name[11];
	int age;

};

// 파일 "개천마리.dat"는 이름순으로 정렬되어 있다.
// 읽어서 한 줄 마다 다음 형식으로 출력하라
// 이름: xxxxxxxxxx    나이: x살

int main()
{
	ifstream in("개천마리.dat",ios::binary);

	Dog dog;

	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&dog, sizeof(Dog));
		cout << "이름: " << (char*)&dog << "나이:" << endl;
	}


	save("main.cpp");
}





===============
 Thu Mar 14 17:59:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
//
// 책소개
// 줴네뤽 프로구래밍 stl코드는 말이지 제네릭 코드인데 니가 손으로 짠거보다 이걸 쓰는게 좋을걸
// 방법보다는 목적을 설명하려고 노력
// 이 책을 위한 선수지식 C++,templete
// 이 책을 보는 방법 -> 처음부터 읽으세연
// 진짜중요한점 -> 프로그램을 책만읽고 이해하는건 아니다. 손으로 하나하나 쳐봐라. 내려받은 예제코드는 의미없누
// 실수하는 과정이 바로 실력이 늘어나는것이다.sequence
// 8장이 존나 액기스임 몰래 훔쳐서 잘라두자.
// 10장은 존나 골치아프다 잠이 안올때 읽으셈
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>

#include "Save.h"
using namespace std;

class Dog
{
private:
	char name[11];
	int age;

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << "     나이: " << dog.age << "살";
	return os;
}

// 파일 "개천마리.dat"는 이름순으로 정렬되어 있다.
// 읽어서 한 줄 마다 다음 형식으로 출력하라
// 이름: xxxxxxxxxx    나이: x살

int main()
{
	ifstream in("개천마리.dat",ios::binary);

	Dog dog;

	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&dog, sizeof(Dog));
		cout << dog << endl;
	}


	save("main.cpp");
}





===============
 Thu Mar 14 18:00:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 3/12
//
// - 이 내용을 객체로(class Dog)
// - smart pointer
// - callable type
// - 알고리즘 시간 재기
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>

#include "Save.h"
using namespace std;

class Dog
{
private:
	char name[11];
	int age;

	friend ostream& operator<<(ostream&, const Dog&);

};

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << "     나이: " << dog.age << "살";
	return os;
}

// 파일 "개천마리.dat"는 이름순으로 정렬되어 있다.
// 읽어서 한 줄 마다 다음 형식으로 출력하라
// 이름: xxxxxxxxxx    나이: x살

int main()
{
	ifstream in("개천마리.dat",ios::binary);

	Dog dog;

	for (int i = 0; i < 1000; ++i)
	{
		in.read((char*)&dog, sizeof(Dog));
		cout << dog << endl;
	}


	save("main.cpp");
}





===============
 Thu Mar 14 18:07:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	//123밀리초 동안 프로그램 시간을 쓰는코드
	this_thread::sleep_for( 123ms );

	save("main.cpp");
}





===============
 Thu Mar 14 18:07:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	//123밀리초 동안 프로그램 시간을 쓰는코드
	this_thread::sleep_for( 5ms);

	save("main.cpp");
}





===============
 Thu Mar 14 18:14:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	auto b = chrono::steady_clock::now();// 시간 재기 시작
	this_thread::sleep_for( 123ms);
	auto e = chrono::steady_clock::now();//시간 재기 끝

	auto d = e - b;
	cout << d.count() << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:17:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	auto b = chrono::steady_clock::now();// 시간 재기 시작
	this_thread::sleep_for( 123ms);
	auto e = chrono::steady_clock::now();//시간 재기 끝

	auto d = e - b;
	auto t = chrono::duration_cast<chrono::milliseconds>(d);
	cout << t.count() << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:18:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	auto b = chrono::steady_clock::now();// 시간 재기 시작
	this_thread::sleep_for( 1ms);
	auto e = chrono::steady_clock::now();//시간 재기 끝

	auto d = e - b;
	auto t = chrono::duration_cast<chrono::milliseconds>(d);
	cout << t.count() << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:20:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{

	auto b = chrono::steady_clock::now();
	this_thread::sleep_for( 30ms);
	cout << (chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - b).count()) << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:21:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{
	using namespace std::chrono;

	auto b = chrono::steady_clock::now();

	this_thread::sleep_for( 30ms);

	cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:22:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{
	using namespace std::chrono;

	auto b = chrono::steady_clock::now();

	this_thread::sleep_for( 123us);

	cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:22:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// - 알고리즘 시간 재기
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// 프로그램의 실행시간을 재는 방법

int main()
{
	using namespace std::chrono;

	auto b = chrono::steady_clock::now();

	this_thread::sleep_for( 123456us);

	cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;

	save("main.cpp");
}





===============
 Thu Mar 14 18:33:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

int main()
{

	auto f = jump;
	f();     // 1:점프, 2:슬라이드
	save("main.cpp");
}





===============
 Thu Mar 14 18:44:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}
int main()
{
	void (*f)() = jump;
	f(); // f는 함수포인터로 호출 가능 타입의 일종이다.

	[]() {
		cout << "안녕, 난 람다야. 우리 친구할래" << endl;
	}();

	save("main.cpp");
}





===============
 Thu Mar 14 18:45:22 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}
int main()
{
	void (*f)() = jump;
	f(); // f는 함수포인터로 호출 가능 타입의 일종이다.

	auto g = []() 
	{
		cout << "안녕, 난 람다야. 우리 친구할래" << endl;
	};

	g();

	save("main.cpp");
}





===============
 Thu Mar 14 18:47:41 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>

#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}
};

int main()
{
	void (*f)() = jump;
	f(); // f는 함수포인터로 호출 가능 타입의 일종이다.

	auto g = []() 
	{
		cout << "안녕, 난 람다야. 우리 친구할래" << endl;
	};

	g(); //람다를 가리키는 포인터이고 호출가능하다.

	Dog d;
	d(); // d는 호출 가능한 객체이다.

	save("main.cpp");
}





===============
 Thu Mar 14 18:59:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark()
	{
		cout << "왈" << endl;
	}
};

int main()
{
	function<void()> f = jump;
	f(); // f는 함수포인터로 호출 가능 타입의 일종이다.

	function<void()> g = []() 
	{
		cout << "안녕, 난 람다야. 우리 친구할래" << endl;
	};

	g(); //람다를 가리키는 포인터이고 호출가능하다.

	Dog d;
	//function<> d(); // d는 호출 가능한 객체이다.

	function<void(Dog)> h = &Dog::bark;

	h(d); // 멤버함수 호출하기

	save("main.cpp");
}





===============
 Tue Mar 19 17:28:45 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark()
	{
		cout << "왈" << endl;
	}
};

int main()
{
	void(*f1)(void) = jump;
	cout << typeid(f1).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 17:31:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark()
	{
		cout << "왈" << endl;
	}
};

int main()
{
	void(*f1)(void) = jump;
	cout << typeid(f1).name() << endl;

	auto f2 = []() { cout << "람다" << endl; };
	cout << typeid(f2).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 17:37:34 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark()
	{
		cout << "왈" << endl;
	}
};

int main()
{
	void(*f1)(void) = jump;
	cout << typeid(f1).name() << endl;

	auto f2 = [  ]() 
	{
		cout << "람다" << endl;
		
	}; //1.이름이 없다
	   //2.캡처절

	cout << typeid(f2).name() << endl;

	Dog d;
	void (Dog::* f3)(void) = &Dog::operator(); //C++ 멤버함수 포인터
	//(d.*f3)();

	cout << typeid(f3).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 17:41:20 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark(int )
	{
		cout << "왈" << endl;
	}
};

int main()
{
	void(*f1)(void) = jump;
	cout << typeid(f1).name() << endl;

	auto f2 = [  ]() 
	{
		cout << "람다" << endl;
		
	}; //1.이름이 없다
	   //2.캡처절

	cout << typeid(f2).name() << endl;

	Dog d;
	void (Dog::* f3)(void) = &Dog::operator(); //C++ 멤버함수 포인터
	//(d.*f3)();

	cout << typeid(f3).name() << endl;

	Dog* pd = new Dog;
	auto f4 = &Dog::bark;
	//(pd->*f4)(3);

	cout << typeid(f4).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 17:44:43 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark(int )
	{
		cout << "왈" << endl;
	}
};

int main()
{
	void(*f1)(void) = jump;
	cout << typeid(f1).name() << endl;

	auto f2 = [  ]() 
	{
		cout << "람다" << endl;
		
	}; //1.이름이 없다
	   //2.캡처절

	cout << typeid(f2).name() << endl;

	Dog d;
	void (Dog::* f3)(void) = &Dog::operator(); //C++ 멤버함수 포인터
	//(d.*f3)();

	cout << typeid(f3).name() << endl;

	Dog* pd = new Dog;
	auto f4 = &Dog::bark;
	//(pd->*f4)(3);

	cout << typeid(f4).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 17:52:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - callable type

// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <thread>
#include <chrono>
#include <functional>
#include "Save.h"
using namespace std;

// Callable type - 호출 가능 타입

void jump()
{
	cout << "점프" << endl;
}

void slide()
{
	cout << "슬라이드" << endl;
}

class Dog
{
public:
	void operator()()
	{
		cout << "난 개" << endl;
	}

	void bark(int )
	{
		cout << "왈" << endl;
	}
};

int main()
{
	function<void(void)> f1 = jump;
	cout << typeid(f1).name() << endl;

	function<void(void)> f2 = []() {};
	cout << typeid(f2).name() << endl;

	function<void(Dog* const)> f3 = &Dog::operator();
	cout << typeid(f3).name() << endl;

	function<void(Dog* const,int)> f4 = &Dog::bark;
	cout << typeid(f4).name() << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 18:07:28 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// 
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include "Save.h"

using namespace std;

// 정수를 인자로 받아 그 숫자만큼 (byte단위) HEAP에서 메모리를 확보한다.
// 확보한 메모리를 임의의 소문자로 채워라 (uid(dre))
// main에서 요구하는대로 실행되도록 하자

class String
{
	char* p;
	int num;
public:
	String(int n): num(n)
	{
		p = new char[n];

		uniform_int_distribution<int> uid('a', 'z');
		default_random_engine dre;

		for (int i = 0; i < n; ++i)
		{
			p[i] = uid(dre);
		}
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
	{
		os << s.p[i] << " ";
	}
	os << endl;
	return os;
}


int main()
{
	String a{ 123 }; // 123개의 제멋대로 임의의 글자로 채운 123byte HEAP을 생성

	cout << a << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 18:07:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// 
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include "Save.h"

using namespace std;

// 정수를 인자로 받아 그 숫자만큼 (byte단위) HEAP에서 메모리를 확보한다.
// 확보한 메모리를 임의의 소문자로 채워라 (uid(dre))
// main에서 요구하는대로 실행되도록 하자

class String
{
	char* p;
	int num;
public:
	String(int n): num(n)
	{
		p = new char[n];

		uniform_int_distribution<int> uid('a', 'z');
		default_random_engine dre;

		for (int i = 0; i < n; ++i)
		{
			p[i] = uid(dre);
		}
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
	{
		os << s.p[i] << " ";
	}
	os << endl;
	return os;
}


int main()
{
	String a{ 123 }; // 123개의 제멋대로 임의의 글자로 채운 123byte HEAP을 생성

	cout << a << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 18:10:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// 
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include "Save.h"

using namespace std;

// 정수를 인자로 받아 그 숫자만큼 (byte단위) HEAP에서 메모리를 확보한다.
// 확보한 메모리를 임의의 소문자로 채워라 (uid(dre))
// main에서 요구하는대로 실행되도록 하자

class String
{
	char* p;
	int num;
public:
	String(int n): num(n)
	{
		p = new char[n];

		uniform_int_distribution<int> uid('a', 'z');
		default_random_engine dre;

		for (int i = 0; i < n; ++i)
		{
			p[i] = uid(dre);
		}
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
	{
		os << s.p[i] << " ";
	}
	os << endl;
	return os;
}


int main()
{
	String a{ 123 }; // 123개의 제멋대로 임의의 글자로 채운 123byte HEAP을 생성

	cout << a << endl;

	save("main.cpp");
}





===============
 Tue Mar 19 18:23:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// 
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include "Save.h"

using namespace std;

// 정수를 인자로 받아 그 숫자만큼 (byte단위) HEAP에서 메모리를 확보한다.
// 확보한 메모리를 임의의 소문자로 채워라 (uid(dre))
// main에서 요구하는대로 실행되도록 하자

class String
{
private:
	char* p;
	int num;
public:
	String(int n): num(n)
	{
		p = new char[n];

		uniform_int_distribution<> uid('a', 'z');
		default_random_engine dre;

		for (int i = 0; i < n; ++i)
		{
			p[i] = uid(dre);
		}
	}

	~String()
	{
		delete[] p;
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
	{
		os << s.p[i] << " ";
	}
	os << endl;
	return os;
}


int main()
{
	String a{ 123 }; // 123개의 제멋대로 임의의 글자로 채운 123byte HEAP을 생성

	String b = a;
	cout << a << endl; //123개 출력

	save("main.cpp");
}





===============
 Tue Mar 19 18:30:46 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// 
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <random>
#include "Save.h"

using namespace std;

// 정수를 인자로 받아 그 숫자만큼 (byte단위) HEAP에서 메모리를 확보한다.
// 확보한 메모리를 임의의 소문자로 채워라 (uid(dre))
// main에서 요구하는대로 실행되도록 하자


// 클래스가 자원을 확보한다면
// 1. 생성자에서 new로 자원을 확보
// 2. 소멸자에서 delete
// 3. 복사생성자에서 깊은복사
// 4. 할당연산자에서 깊은복사

class String
{
private:
	char* p;
	int num;
public:
	String(int n): num(n)
	{
		p = new char[n];

		uniform_int_distribution<> uid('a', 'z');
		default_random_engine dre;

		for (int i = 0; i < n; ++i)
		{
			p[i] = uid(dre);
		}
	}

	String(const String& other) : num(other.num)
	{
		p = new char[num];

		memcpy(p, other.p, num);
	}

	String& operator= (const String& other)
	{
		if (this == &other)
		{
			return *this;
		}

		delete[] p;
		num = other.num;

		p = new char[num];
		memcpy(p, other.p, num);

		return *this;
	}

	~String()
	{
		delete[] p;
	}

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i = 0; i < s.num; ++i)
	{
		os << s.p[i] << " ";
	}
	os << endl;
	return os;
}


int main()
{
	String a{ 10 };

	String b{ 12 };


	cout << a << endl; 
	cout << b << endl;

	a = b;

	cout << a << endl;
	cout << b << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 17:45:33 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

int main()
{
	String s[100];

	//100개의 String을 임의의 갯수로 (1,80)로 설정하라

	uniform_int_distribution<> uidNum(1, 80);

	for (String& d : s)
	{
		cout << endl;
		d.set(uidNum(dre));
	}
	
	//string의 num 오름차순으로 정렬하라

	sort(begin(s), end(s), [](String a, String b) {return a.get() > b.get(); });

	for (String d : s)
	{
		cout << d << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 21 17:46:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

int main()
{
	String s[100];

	//100개의 String을 임의의 갯수로 (1,80)로 설정하라

	uniform_int_distribution<> uidNum(1, 80);

	for (String& d : s)
	{
		cout << endl;
		d.set(uidNum(dre));
	}
	
	//string의 num 오름차순으로 정렬하라

	sort(begin(s), end(s), [](String a, String b) {return a.get() > b.get(); });

	for (String d : s)
	{
		cout << d << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 21 17:50:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

int main()
{
	String s[10];

	//100개의 String을 임의의 갯수로 (1,80)로 설정하라

	uniform_int_distribution<> uidNum(1, 80);

	for (String& d : s)
	{
		d.set(uidNum(dre));
	}
	
	//string의 num 오름차순으로 정렬하라

	sort(begin(s), end(s), [](const String& a, const String& b) {return a.get() > b.get(); });

	for (const String& d : s)
	{
		cout << d << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 21 17:52:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

int main()
{
	String a{ 10 };

	cout << a << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 17:53:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

int main()
{
	String* a = new String(10);

	cout << *a << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 17:58:31 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>

#include "Save.h"
#include "String.h"

int main()
{
	unique_ptr<String> a(new String{ 20 });

	cout << *a << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 18:10:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	String* s = new String[10];
	
	for (int i = 0; i < 10; ++i)
	{
		s[i].set(myUID(myDRE));
	}

	sort(s, s + 10, [](const String& a, const String& b) {
		return a.get() < b.get();
	});

	save("main.cpp");
}





===============
 Thu Mar 21 18:10:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	String* s = new String[10];
	
	for (int i = 0; i < 10; ++i)
	{
		s[i].set(myUID(myDRE));
	}

	sort(s, s + 10, [](const String& a, const String& b) {
		return a.get() < b.get();
	});

	for (int i = 0; i < 10; ++i)
	{
		cout << s[i] << endl;
	}
	save("main.cpp");
}





===============
 Thu Mar 21 18:13:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>
#include <random>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	String* s = new String[10];
	
	for (int i = 0; i < 10; ++i)
	{
		s[i].set(myUID(myDRE));
	}

	sort(s, s + 10, [](const String& a, const String& b) {
		return a.get() < b.get();
	});

	for (int i = 0; i < 10; ++i)
	{
		cout << s[i] << endl;
	}

	delete[] s;
	save("main.cpp");
}





===============
 Thu Mar 21 18:15:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>
#include <random>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	unique_ptr<String[]> s (new String[10]);
	
	for (int i = 0; i < 10; ++i)
	{
		s[i].set(myUID(myDRE));
	}

	sort(s.get(), s.get() + 10, [](const String& a, const String& b) {
		return a.get() < b.get();
	});

	for (int i = 0; i < 10; ++i)
	{
		cout << s[i] << endl;
	}


	save("main.cpp");
}





===============
 Thu Mar 21 18:18:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// -->함수의 동작을 수정하는데 사용한다
//      sort로 callable type을 활용하는 방법을 복습하자
//
// 자원을 확보하는 클래스를 만들어 놓기
// - smart pointer
//
// 과제 - 책 1장 공부하자
// class String을 #include "String.h"로 분리하자
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>
#include <random>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	//unique_ptr<String[]> s (new String[10]);

	auto s = make_unique<String[]>(10);
	
	for (int i = 0; i < 10; ++i)
	{
		s[i].set(myUID(myDRE));
	}

	sort(s.get(), s.get() + 10, [](const String& a, const String& b) {
		return a.get() < b.get();
	});

	for (int i = 0; i < 10; ++i)
	{
		cout << s[i] << endl;
	}


	save("main.cpp");
}





===============
 Thu Mar 21 18:25:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <memory>
#include <random>

#include "Save.h"
#include "String.h"


// String 객체 10개를 동적할당하라 
// Data
// num순으로 정렬하라
// 출력하라

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	unique_ptr<String> p[5];
	p[0] = make_unique<String>(10);
	p[1] = make_unique<String>(50);
	p[2] = make_unique<String>(20);
	p[3] = make_unique<String>(40);
	p[4] = make_unique<String>(30);



	sort(begin(p), end(p), []
	(const unique_ptr<String>& a, const unique_ptr<String>& b)
	{
		return a->get() < b->get();
	});

	for (auto& d : p)
	{
		cout << *d << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 21 18:28:32 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// - smart pointer
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"


//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	unique_ptr<String> s;
	cout << sizeof(s) << endl;

	shared_ptr<String> t;
	cout << sizeof(t) << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 18:49:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5];

	s[0] = "살기싫다";
	s[1] = "자퇴하고싶다";
	s[2] = "내일일어나기싫다";
	s[3] = "집에가고싶다";
	s[4] = "탈주각";

	auto beg = begin(s);
	cout << *beg << endl;

	save("main.cpp");
}





===============
 Thu Mar 21 18:50:33 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5];

	s[0] = "살기싫다";
	s[1] = "자퇴하고싶다";
	s[2] = "내일일어나기싫다";
	s[3] = "집에가고싶다";
	s[4] = "탈주각";

	for (auto iter = begin(s); iter != end(s); ++iter)
	{
		cout << *iter << endl;
	}

	save("main.cpp");
}





===============
 Tue Mar 26 17:30:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "살기싫다","자퇴하고싶다","내일일어나기싫다","집에가고싶다","탈주각" };

	

	save("main.cpp");
}





===============
 Tue Mar 26 17:31:23 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "살기싫다","자퇴하고싶다","내일일어나기싫다","집에가고싶다","탈주각" };

	

	save("main.cpp");
}





===============
 Tue Mar 26 17:31:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{

	cout << sizeof(string) << endl; // 24바이트일걸?(내컴퓨터에서는)
	string s[5]{ "살기싫다","자퇴하고싶다","내일일어나기싫다","집에가고싶다","탈주각" };

	

	save("main.cpp");
}





===============
 Tue Mar 26 17:40:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////

// std::string 객체로 된 배열을 정의하고 자신이 선택한 단어들로 초기화 한 후에
// 반복자를 사용하여 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라
// 

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;
//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "살기싫다","자퇴하고싶다","내일일어나기싫다","집에가고싶다","탈주각" };
	
	auto p = begin(s);

	for (auto i = begin(s); i != end(s); ++i)
	{
		cout << *i << endl;
	}

	save("main.cpp");
}





===============
 Tue Mar 26 17:51:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "lkgruhegivsub","fkyrvqwbgyui","viufebgwai","fveuiabvgiuors","fviobeagwiu" };
	
	transform(begin(s),end(s),ostream_iterator<string>(cout,"\n"),
		[](string& str) 
	{
		for (auto i = begin(str); i != end(str); ++i)
		{
			if (*i == 'a' || *i == 'e' || *i == 'i' || *i == 'o' || *i == 'u')
			{
				*i = '*';
			}
		}

		return str;
	}
	);

	for (auto i = begin(s); i != end(s); ++i)
	{
		cout << *i << endl;
	}

	save("main.cpp");
}





===============
 Tue Mar 26 17:54:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "lkgruhegivsub","fkyrvqwbgyui","viufebgwai","fveuiabvgiuors","fviobeagwiu" };
	
	transform(begin(s),end(s),ostream_iterator<string>(cout,"\n"),
		[](const string& str) 
	{
		string s = str;
		for (auto i = begin(s); i != end(s); ++i)
		{
			
			if (*i == 'a' || *i == 'e' || *i == 'i' || *i == 'o' || *i == 'u')
			{
				*i = '*';
			}
		}

		return s;
	}
	);

	for (string&d : s)
	{
		cout << s << endl;
	}

	save("main.cpp");
}





===============
 Tue Mar 26 17:54:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "lkgruhegivsub","fkyrvqwbgyui","viufebgwai","fveuiabvgiuors","fviobeagwiu" };
	
	transform(begin(s),end(s),ostream_iterator<string>(cout,"\n"),
		[](const string& str) 
	{
		string s = str;
		for (auto i = begin(s); i != end(s); ++i)
		{
			
			if (*i == 'a' || *i == 'e' || *i == 'i' || *i == 'o' || *i == 'u')
			{
				*i = '*';
			}
		}

		return s;
	}
	);

	for (string& d : s)
	{
		cout << *s << endl;
	}

	save("main.cpp");
}





===============
 Tue Mar 26 18:01:45 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "lkgruhegivsub","fkyrvqwbgyui","viufebgwai","fveuiabvgiuors","fviobeagwiu" };
	
	transform(begin(s),end(s),ostream_iterator<string>(cout,"\n"),
		[]( string& str) 
	{
		string s = str;
		for (auto i = begin(s); i != end(s); ++i)
		{
			
			if (*i == 'a' || *i == 'e' || *i == 'i' || *i == 'o' || *i == 'u')
			{
				*i = '*';
			}

			toupper(*i);
		}

		return s;

		
	}
	);



	save("main.cpp");
}





===============
 Tue Mar 26 18:02:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	string s[5]{ "lkgruhegivsub","fkyrvqwbgyui","viufebgwai","fveuiabvgiuors","fviobeagwiu" };
	
	transform(begin(s),end(s),ostream_iterator<string>(cout,"\n"),
		[]( string& str) 
	{
		string s = str;
		for (auto i = begin(s); i != end(s); ++i)
		{
			
			if (*i == 'a' || *i == 'e' || *i == 'i' || *i == 'o' || *i == 'u')
			{
				*i = '*';
			}

			*i = toupper(*i);
		}

		return s;

		
	}
	);



	save("main.cpp");
}





===============
 Tue Mar 26 18:09:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	


	save("main.cpp");
}





===============
 Tue Mar 26 18:30:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };
	
	for (int i = 0; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:30:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };
	
	for (int i = 0; i < (int)a.size(); ++i)
	{
		cout << a[i] << endl;
	}
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:32:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };
	
	/*for (unsigned int i = 0; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}*/

	for (auto i = a.begin(); i != a.end(); ++i)
	{
		cout << *i << endl;
	}
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:33:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };
	
	/*for (unsigned int i = 0; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}*/
	auto i = a.begin();
	while (i != a.end())
	{
		cout << *i++ << endl;
		
	}
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:36:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };
	
	/*for (unsigned int i = 0; i < a.size(); ++i)
	{
		cout << a[i] << endl;
	}*/
	auto i = a.begin();
	while (i != a.end())
	{
		cout << *i++ << endl;
		
	}
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:51:20 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<int, 5> a{ 1,2,3,4,5 };

	/*while (true)
	{
		cout << "몇 번 값을 원하나요?:";
		int num;
		cin >> num;

		try 
		{
			cout << a.at(num) << endl;
		}
		catch (exception& e)
		{
			cout << e.what() << endl;
		}
	}*/
	
	
	

	save("main.cpp");
}





===============
 Tue Mar 26 18:54:44 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 10,20,30,40,50 };

	
	save("main.cpp");
}





===============
 Tue Mar 26 18:59:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 10,20,30,40,50 };


	for (int i = 0; i < a.size(); ++i)
	{
		sort(a[i].getP(), a[i].getP() + a[i].get());
	}

	for (auto i = a.begin(); i != a.end(); ++i)
	{
		cout << *i << endl;
	}
	
	save("main.cpp");
}





===============
 Tue Mar 26 18:59:16 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 100,200,300,400,500 };


	for (int i = 0; i < a.size(); ++i)
	{
		sort(a[i].getP(), a[i].getP() + a[i].get());
	}

	for (auto i = a.begin(); i != a.end(); ++i)
	{
		cout << *i << endl;
	}
	
	save("main.cpp");
}





===============
 Thu Mar 28 17:45:55 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 100,200,300,400,500 };


	for (int i = 0; i < a.size(); ++i)
	{
		sort(a[i].getP(), a[i].getP() + a[i].get());
	}

	for (auto i = a.begin(); i != a.end(); ++i)
	{
		cout << *i << endl;
	}
	
	save("main.cpp");
}





===============
 Thu Mar 28 17:49:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 100,200,300,400,500 };


	for (int i = 0; i < a.size(); ++i)
	{
		sort(a[i].getP(), a[i].getP() + a[i].get(), [](char a, char b)
		{
			return a > b;
		}
		);
	}

	for (auto i = a.rbegin(); i != a.rend(); ++i)
	{
		cout << *i << endl;
	}
	
	save("main.cpp");
}





===============
 Thu Mar 28 18:04:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <array>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	array<String, 5> a{ 100,200,300,400,500 };


	for (int i = 0; i < a.size(); ++i)
	{
		sort(a[i].getData(), a[i].getData() + a[i].getNum(), [](char a, char b)
		{
			return a > b;
		}
		);
	}

	for (auto i = a.rbegin(); i != a.rend(); ++i)
	{
		cout << *i << endl;
	}
	
	save("main.cpp");
}





===============
 Thu Mar 28 18:07:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v;
	vector <int> vi;
	cout << sizeof(v) << endl;
	cout << sizeof(vi) << endl;
	
	save("main.cpp");
}





===============
 Thu Mar 28 18:19:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v(5);
	
	// 화면 추력 해 보세요
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 28 18:19:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v(5);
	
	// 화면 추력 해 보세요
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 28 18:23:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v { 1,3,5,7,9 };
	
	// 화면 출력 해 보세요
	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 28 18:26:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v { 1,3,5,7,9 };
	
	// 화면 출력 해 보세요
	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		cout << *iter << endl;
	}

	save("main.cpp");
}





===============
 Thu Mar 28 18:31:34 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v { 1,3,5,7,9 };
	
	// 화면 출력 해 보세요
	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		cout << *iter << endl;
	}

	cout << "SIZE     - " << v.size() << endl;
	cout << "CAPACITY - " << v.capacity() << endl;

	save("main.cpp");
}





===============
 Thu Mar 28 18:34:02 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

int main()
{
	vector<String> v { 1,3,5,7,9 };
	
	// 화면 출력 해 보세요
	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		cout << *iter << endl;
	}

	cout << "SIZE     - " << v.size() << endl;
	cout << "CAPACITY - " << v.capacity() << endl;

	//원소 한개 추가
	v.push_back(10);

	cout << "SIZE     - " << v.size() << endl;
	cout << "CAPACITY - " << v.capacity() << endl;

	save("main.cpp");
}





===============
 Thu Mar 28 18:42:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	vector<String> v;

	//v의 길이가 uid(dre)인 String 20개를 추가하라
	//v의 String을 길이 오름차순으로 정렬하라
	//v의 모든 String을 출력하라

	for (int i = 0; i < 20; ++i)
	{
		v.push_back(myUID(myDRE));
	}
	
	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		sort(iter->getData(), iter->getData() + iter->getNum());
	}

	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		cout << *iter << endl;
	}


	
	save("main.cpp");
}





===============
 Thu Mar 28 18:47:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	vector<String> v;

	//v의 길이가 uid(dre)인 String 20개를 추가하라
	//v의 String을 길이 오름차순으로 정렬하라
	//v의 모든 String을 출력하라

	for (int i = 0; i < 20; ++i)
	{
		v.push_back(myUID(myDRE));
	}
	
	sort(v.begin(), v.end(), [](String& a, String& b) 
	{
		return a.getNum() < b.getNum();
	});

	for (auto iter = v.begin(); iter != v.end(); ++iter)
	{
		cout << *iter << endl;
	}


	
	save("main.cpp");
}





===============
 Thu Mar 28 19:00:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array
// - Vector
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

uniform_int_distribution<int> myUID(1, 80);
default_random_engine myDRE;

int main()
{
	vector<String> v;

	//v의 길이가 uid(dre)인 String 20개를 추가하라
	//v의 String을 길이 오름차순으로 정렬하라
	//v의 모든 String을 출력하라

	v.reserve(20);
	for (int i = 0; i < 20; ++i)
	{
		v.emplace_back(myUID(myDRE));
	}
	
	sort(v.begin(), v.end(), [](const String& a, const String& b) 
	{
		return a.getNum() < b.getNum();
	});

	for (const String& s:v)
	{
		cout << s << endl;
	}


	
	save("main.cpp");
}





===============
 Tue Apr  2 18:56:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면
int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>() };
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("main.cpp");
}





===============
 Tue Apr  2 18:59:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면
int main()
{
	vector<int> v{ istream_iterator<int>(cin), istream_iterator<int>() };
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<int>(cout));

	save("main.cpp");
}





===============
 Tue Apr  2 18:59:13 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면
int main()
{
	vector<int> v{ istream_iterator<int>(cin), istream_iterator<int>() };
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<int>(cout));

	save("main.cpp");
}





===============
 Tue Apr  2 18:59:41 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면
int main()
{
	vector<char> v{ istream_iterator<char>(cin), istream_iterator<char>() };
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<char>(cout));

	save("main.cpp");
}





===============
 Thu Apr  4 17:27:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<char> v{ istream_iterator<char>(cin), istream_iterator<char>() };
	sort(v.begin(), v.end());
	
	copy(v.begin(), v.end(), ostream_iterator<char>(cout));

	save("main.cpp");
}





===============
 Thu Apr  4 17:29:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(String{ 10 });
	v.emplace_back(String{ 20 });


	save("main.cpp");
}





===============
 Thu Apr  4 17:30:13 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(String{ 10 });
	v.emplace_back(String{ 20 });


	save("main.cpp");

	cout << endl << endl;
}





===============
 Thu Apr  4 17:32:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10 );
	v.emplace_back(20);


	save("main.cpp");

	cout << endl << endl;
}





===============
 Thu Apr  4 17:36:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);

	//여기에서 10과 20 사이에 15를 삽입하자
	v.emplace(v.begin() + 1, 15);


	save("main.cpp");

	cout << endl << endl;
}





===============
 Thu Apr  4 17:37:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);

	//여기에서 10과 20 사이에 15를 삽입하자
	v.emplace(v.begin() + 1, 15);




	save("main.cpp");

	cout << endl << endl;

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}





===============
 Thu Apr  4 17:40:17 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);

	//여기에서 10과 20 사이에 15를 삽입하자
	v.emplace_back(15);




	save("main.cpp");

	cout << endl << endl;

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}





===============
 Thu Apr  4 17:40:43 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);

	//여기에서 10과 20 사이에 15를 삽입하자
	v.emplace_back(15);   //중간에 집어넣는 동작은 연속된 메모리에게는 힘든 작업이다 불필요한 연산이 수행된다




	save("main.cpp");

	cout << endl << endl;

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}





===============
 Thu Apr  4 17:43:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 키보드에서 단어를 읽어 정렬 후 화면에 출력하라
// 입력자료구조 - 키보드
// 출력자료구조 - 화면

int main()
{
	vector<String> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(15);

	//벡터의 2번째원소를 삭제해보자
	v.erase(v.begin()+1);


	save("main.cpp");

	cout << endl << endl;

	for (int i = 0; i < v.size(); ++i)
	{
		cout << v[i] << endl;
	}
}





===============
 Thu Apr  4 18:32:46 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <iterator>
#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 입력: main.cpp
// 출력: 소스.###
// 변신과정: 입력파일에서 #dmf wprjgksek.
int main()
{
	ifstream in("main.cpp");
	ofstream out("소스.###");


	vector<char> v{ istreambuf_iterator<char>(in), istreambuf_iterator<char>() };
	v.erase(remove(v.begin(), v.end(), '#'), v.end());
	copy(v.begin(), v.end(), ostreambuf_iterator<char>(out));
	save("main.cpp");
}





===============
 Thu Apr  4 18:36:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// "덱"에 String객체를 1,2,3,4,5를 추가해보자
// 화면에 "덱"의 원소를 출력해보자
int main()
{
	deque<String> d;
	for (int i = 1; i <= 5; ++i)
	{
		d.emplace_back(i);
	}
	for (const auto& i : d)
	{
		cout << i << endl;
	}

	save("main.cpp");
}





===============
 Thu Apr  4 18:38:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// "덱"에 String객체를 1,2,3,4,5를 추가해보자
// 화면에 "덱"의 원소를 출력해보자
int main()
{
	deque<String> d{ 1,2,3,4,5 };

	for (const auto& i : d)
	{
		cout << i << endl;
	}

	save("main.cpp");
}





===============
 Thu Apr  4 18:47:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// "덱"에 String객체를 1,2,3,4,5를 추가해보자
// 화면에 "덱"의 원소를 출력해보자
int main()
{
	deque<String> d;

	d.emplace(d.end(), 1);
	d.emplace(d.end(), 2);
	d.emplace(d.end(), 3);
	d.emplace(d.end(), 4);
	d.emplace(d.end(), 5);

	for (const auto& i : d)
	{
		cout << i << endl;
	}

	save("main.cpp");
}





===============
 Thu Apr  4 18:48:18 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// "덱"에 String객체를 1,2,3,4,5를 추가해보자
// 화면에 "덱"의 원소를 출력해보자
int main()
{
	deque<String> d;

	d.emplace(d.begin(), 1);
	d.emplace(d.begin(), 2);
	d.emplace(d.begin(), 3);
	d.emplace(d.begin(), 4);
	d.emplace(d.begin(), 5);

	for (const auto& i : d)
	{
		cout << i << endl;
	}

	save("main.cpp");
}





===============
 Thu Apr  4 18:53:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// "덱"에 String객체를 1,2,3,4,5를 추가해보자
// 화면에 "덱"의 원소를 출력해보자
int main()
{
	deque<String> d;

	d.emplace(d.begin(), 1);
	d.emplace(d.begin(), 2);
	d.emplace(d.begin(), 3);
	d.emplace(d.begin(), 4);
	d.emplace(d.begin(), 5);

	for (const auto& i : d)
	{
		cout << i << endl;
	}

	save("main.cpp");
}





===============
 Tue Apr  9 17:28:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(), d.end(), ostream_iterator<String>(cout, "\n"));

	save("main.cpp");
}





===============
 Tue Apr  9 17:31:31 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:32:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.push_back(10);
	d.push_back(20);
	d.push_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:34:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:40:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:41:23 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>
#include <vector>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	vector<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:41:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>
#include <vector>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:42:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>
#include <vector>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:42:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>
#include <vector>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);

	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 17:44:15 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <string>
#include <vector>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 키보드에서 숫자를 입력받아 
// 그 숫자를 인자로 String을 생성하여
// deque에 back위치에 삽입하라.

int main()
{
	deque<String> d;
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);
	d.emplace_back(40);
	d.emplace_back(50);
	d.emplace_back(50);
	d.emplace_back(50);
	d.emplace_back(50);
	d.emplace_back(50);
	d.emplace_back(50);
	d.emplace_back(50);


	copy(d.begin(),d.end(),ostream_iterator<String>(cout,"\n"));
	

	save("main.cpp");
}





===============
 Tue Apr  9 18:01:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{

	ifstream in("main.cpp");

	deque<char> d{ istream_iterator<char>(in),istream_iterator<char>() };
	copy(d.rbegin(), d.rend(), ostream_iterator<char>(cout));

	save("main.cpp");
}





===============
 Tue Apr  9 18:05:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));

	save("main.cpp");
}





===============
 Tue Apr  9 18:12:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	//copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	istreambuf_iterator<char> p(in);
	while (p != istreambuf_iterator<char>())
	{
		cout << *p;
	}
	save("main.cpp");
}





===============
 Tue Apr  9 18:12:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	//copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	istreambuf_iterator<char> p(in);
	while (p != istreambuf_iterator<char>())
	{
		cout << *p++;
	}
	save("main.cpp");
}





===============
 Tue Apr  9 18:13:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	//deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	//copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	istreambuf_iterator<char> p(in);
	while (p != istreambuf_iterator<char>())
	{
		cout << *p++;
	}
	save("main.cpp");
}





===============
 Tue Apr  9 18:15:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	//deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	//copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	istreambuf_iterator<char> p(in);
	deque<char> d;
	while (p != istreambuf_iterator<char>())
	{
		d.emplace_front(*p++);
	}
	for (char c : d)
	{
		cout << c;
	}

	save("main.cpp");
}





===============
 Tue Apr  9 18:41:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <deque>
#include <iterator>
#include <fstream>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp를 deque애 저장하자
// 소스.cpp의 내용이 거꾸로 출력되도록 deque에 저장된 내용을 

int main()
{
	ifstream in("main.cpp");
	//deque<char> d{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };
	//copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	istreambuf_iterator<char> p(in);
	deque<char> d;
	while (p != istreambuf_iterator<char>())
	{
		d.emplace_front(*p++);
	}
	for (char c : d)
	{
		cout << c;
	}

	save("main.cpp");
}





===============
 Tue Apr  9 18:43:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l{ 10,20,30 };
	copy(l.begin(), l.end(), ostream_iterator<String>(cout));

	save("main.cpp");
}





===============
 Tue Apr  9 18:44:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l{ 10,20,30 };
	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Tue Apr  9 18:44:43 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l{ 10,20,30 };
	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));
	for (String a : l)
		cout << a;
	save("main.cpp");
}





===============
 Tue Apr  9 18:44:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l{ 10,20,30 };
	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));
	for (const String& a : l)
		cout << a;
	save("main.cpp");
}





===============
 Tue Apr  9 18:47:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l{ 10,20,30 };
	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Tue Apr  9 18:59:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// list<String>에 {10,20,30}을 초기화 또는 추가해보자
// 화면에 출력해보자

int main()
{
	list<String> l;


	l.emplace(l.emplace(l.begin(), 10),20);

	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:33:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	vector<int> v;
	list<String> l;
	cout << v.max_size() << endl;;
	cout << l.max_size() << endl;


	//list<String> l;

	//auto p = l.begin();
	//p = l.emplace(p, 10);
	//p = l.emplace(p, 20);
	//p = l.emplace(p, 30);
	//p = l.emplace(p, 40);
	//p = l.emplace(p, 50);
	//p = l.emplace(p, 60);
	//p = l.emplace(p, 70);
	//p = l.emplace(p, 80);
	//p = l.emplace(p, 90);

	////리스트에서 20의 배수를 제거해주세요.(remove_if)
	//
	//

	//copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:33:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	vector<int> v;
	list<String> l;
	cout << v.max_size() << endl;;
	cout << l.max_size() << endl;


	//list<String> l;

	//auto p = l.begin();
	//p = l.emplace(p, 10);
	//p = l.emplace(p, 20);
	//p = l.emplace(p, 30);
	//p = l.emplace(p, 40);
	//p = l.emplace(p, 50);
	//p = l.emplace(p, 60);
	//p = l.emplace(p, 70);
	//p = l.emplace(p, 80);
	//p = l.emplace(p, 90);

	////리스트에서 20의 배수를 제거해주세요.(remove_if)
	//
	//

	//copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:38:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	

	list<String> l;

	auto p = l.begin();
	p = l.emplace(p, 10);
	p = l.emplace(p, 20);
	p = l.emplace(p, 30);
	p = l.emplace(p, 40);
	p = l.emplace(p, 50);
	p = l.emplace(p, 60);
	p = l.emplace(p, 70);
	p = l.emplace(p, 80);
	p = l.emplace(p, 90);

	//리스트에서 20의 배수를 제거해주세요.(remove_if)

	remove_if(l.begin(), l.end(), [](const String& str) 
	{
		return (str.getNum() % 20 == 0);
	});
	
	

	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:41:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	

	list<String> l;

	auto p = l.begin();
	p = l.emplace(p, 10);
	p = l.emplace(p, 20);
	p = l.emplace(p, 30);
	p = l.emplace(p, 40);
	p = l.emplace(p, 50);
	p = l.emplace(p, 60);
	p = l.emplace(p, 70);
	p = l.emplace(p, 80);
	p = l.emplace(p, 90);

	//리스트에서 20의 배수를 제거해주세요.(remove_if)

	
	l.erase(remove_if(l.begin(), l.end(), [](const String& str) {return (str.getNum() % 20 == 0); }), l.end());
	
	

	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:45:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	

	list<String> l;

	auto p = l.begin();
	p = l.emplace(p, 10);
	p = l.emplace(p, 20);
	p = l.emplace(p, 30);
	p = l.emplace(p, 40);
	p = l.emplace(p, 50);
	p = l.emplace(p, 60);
	p = l.emplace(p, 70);
	p = l.emplace(p, 80);
	p = l.emplace(p, 90);

	//리스트에서 20의 배수를 제거해주세요.(remove_if)

	
	l.remove_if([](const String& str)
	{
		return !(str.getNum() % 20);
	});
	
	

	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:45:15 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	

	list<String> l;

	auto p = l.begin();
	p = l.emplace(p, 10);
	p = l.emplace(p, 20);
	p = l.emplace(p, 30);
	p = l.emplace(p, 40);
	p = l.emplace(p, 50);
	p = l.emplace(p, 60);
	p = l.emplace(p, 70);
	p = l.emplace(p, 80);
	p = l.emplace(p, 90);

	//리스트에서 20의 배수를 제거해주세요.(remove_if)

	
	l.remove_if([](const String& str)
	{
		return !(str.getNum() % 20);
	});
	
	

	copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:57:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라

	str1.merge(str2);


	//copy(l.begin(), l.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:58:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라

	str1.merge(str2);


	copy(str1.begin(), str1.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:58:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라

	str1.merge(str2);


	copy(str1.begin(), str1.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 17:59:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라

	str1.merge(str2);


	copy(str1.begin(), str1.end(), ostream_iterator<String>(cout,"\n"));

	save("main.cpp");
}





===============
 Thu Apr 11 18:03:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라

	str1.merge(str2);

	cout << endl;

	copy(str1.begin(), str1.end(), ostream_iterator<String>(cout,"\n"));

	cout << endl;

	copy(str2.begin(), str2.end(), ostream_iterator<String>(cout, "\n"));

	cout << endl;

	save("main.cpp");
}





===============
 Thu Apr 11 18:08:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	list<String> str1{ 3,5,1 };
	list<String> str2{ 4,2,6 };

	//stl1 =  str1+str2로 만들어라
	//merge하기 전에 sort를 해야 제대로 합쳐질거다.
	str1.sort();
	str2.sort();


	str1.merge(str2);

	cout << endl;

	copy(str1.begin(), str1.end(), ostream_iterator<String>(cout,"\n"));

	cout << endl;

	copy(str2.begin(), str2.end(), ostream_iterator<String>(cout, "\n"));

	cout << endl;

	save("main.cpp");
}





===============
 Thu Apr 11 18:16:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	l.sort([](const string& s1, const string& s2)
	{
		return s1.size() < s2.size();
	});
	copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:40:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	
	//list<string> len5;
	auto len5 = find_if(l.begin(), l.end(), [](const string& str) 
	{
		return (str.length() == 5);
	});

	auto len6 = find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	});

	for (auto i = len5; i != len6; ++i)
	{
		cout << *i << endl;
	}

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:47:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	
	//list<string> len5;
	auto length5 = find_if(l.begin(), l.end(), [](const string& str) 
	{
		return (str.length() == 5);
	});

	auto length6 = find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	});

	for (auto i = length6; i != length6; ++i)
	{
		cout << *i << endl;
	}

	list<string> len5;
	len5.splice(len5.begin(), l, length5, length6);

	for (const string& s : l)
	{
		cout << s << endl;
	}
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:50:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	
	//list<string> len5;
	auto length5 = find_if(l.begin(), l.end(), [](const string& str) 
	{
		return (str.length() == 5);
	});

	auto length6 = find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	});

	for (auto i = length6; i != length6; ++i)
	{
		cout << *i << endl;
	}

	list<string> len5;
	len5.splice(len5.begin(), l, length5, length6);

	ofstream out("길이5.txt");
	copy(len5.begin(), len5.end(), ostream_iterator<string>(out," "));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:51:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	
	//list<string> len5;
	auto length5 = find_if(l.begin(), l.end(), [](const string& str) 
	{
		return (str.length() == 5);
	});

	auto length6 = find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	});


	/*list<string> len5;
	len5.splice(len5.begin(), l, length5, length6);
*/

	ofstream out("길이5.txt");
	copy(length5, length6, ostream_iterator<string>(out," "));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:51:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	
	//list<string> len5;
	auto length5 = find_if(l.begin(), l.end(), [](const string& str) 
	{
		return (str.length() == 5);
	});

	auto length6 = find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	});


	/*list<string> len5;
	len5.splice(len5.begin(), l, length5, length6);
*/

	ofstream out("길이5.txt");
	copy(length5, length6, ostream_iterator<string>(out," "));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:53:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	



	ofstream out("길이5.txt");
	copy(find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 5);
	})
		, 
	find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	})
		,
	ostream_iterator<string>(out," "));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:53:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	



	ofstream out("길이5.txt");
	copy(find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 5);
	})
		, 
	find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	})
		,
	ostream_iterator<string>(out," "));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 18:55:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>
#include <string>
#include <fstream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자
int main()
{
	ifstream in("main.cpp");
	//list<string> l = {istream_iterator<string>(in), istream_iterator<string>()};
	list<string> l;
	//list는 이렇게 집어넣으래요
	copy(istream_iterator<string>(in), istream_iterator<string>(), inserter(l,l.begin()));
	l.sort([](const string& s1, const string& s2)
	{
		return s1.length() < s2.length();
	});

	//길이순으로 정렬한 리스트에서 길이가 5인 단어를 
	//list<string> len5; 으로 이동하자
	//len5를 "길이5.txt" 파일에 저장
	

	ofstream out("길이5.txt");
	copy(find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 5);
	})
		, 
	find_if(l.begin(), l.end(), [](const string& str)
	{
		return (str.length() == 6);
	})
		,
	ostream_iterator<string>(out,"김동순 공부좀해라\n"));
	

	//copy(l.begin(), l.end(), ostream_iterator<string>(cout, "\n"));


	save("main.cpp");
}





===============
 Thu Apr 11 19:02:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


// 소스.cpp를 에 사용된 단어를 길이 오름차순으로 
// list<string>를 사용해보자

//template<class T,class C>
//void print(C::<T>::iterator a, C::<T>::iterator b);

void print(list<int>::iterator b, list<int>::iterator e);
int main()
{
	list<int> numbers{ 1,3,5,7,9 };

	print(numbers.begin(), numbers.end());

	save("main.cpp");
}

void print(list<int>::iterator b, list<int>::iterator e)
{
	while (b != e)
	{
		cout << *b++;
	}
}

=================
Tue Apr 16 17:45:39 2019
=================


//-----------------------------------------------------------
// 2019. STL 4.16 화 9 10                  (화목 7주/1일)
//
// 반복자의 정체는? - STL 반복자가 되려면 필요한 것들은?
// 
//   반복자 어댑터 - copy coding하며 설명
//   중간고사 - 4.25 목 9 10
//-----------------------------------------------------------

#include <iostream> 
#include <list>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;      

template <class Iter>
void print(Iter beg, Iter end);


int main()
{
   vector<int> numbers{ 1,3,5,7,9 };

   print(numbers.begin(), numbers.end());      // 함수 프로그램 해보세요

   save("2019 STL.cpp");
}

template <class Iter>
void print(Iter b, Iter e)
{
   while (b != e)
      cout << *b++;
}





=================
Tue Apr 16 18:11:33 2019
=================


//-----------------------------------------------------------
// 2019. STL 4.16 화 9 10                  (화목 7주/1일)
//
// 반복자의 정체는? - STL 반복자가 되려면 필요한 것들은?
// 
//   반복자 어댑터 - copy coding하며 설명
//   중간고사 - 4.25 목 9 10
//-----------------------------------------------------------

#include <iostream> 
#include <vector>
#include <list>
#include <forward_list>
#include <iterator>
#include "save.h"
#include "String.h"
using namespace std;      

// 반복자의 종류를 화면에 출력해보자
template <class Iter>
void cat(Iter);

int main()
{
   vector<int> v;
   cat(v.begin());      //cat(vector<int>::iterator());

   cat(list<int>::iterator());
   cat(forward_list<int>::iterator());
   cat(istream_iterator<int>());
   cat(ostream_iterator<int>(cout));         // 이것은 어디다가 연결 시켜줘야 사용할 수 있기 때문에 (cout)

   // 반복자라 주장하는 것들은 무조건 이 5가지 중 하나여야 한다.

   double n;
   cat(&n);

   save("2019 STL.cpp");
}

template <class Iter>
void cat(Iter iter)
{
   cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
   cout << typeid(iterator_traits<Iter>::value_type).name() << endl;
}







=================
Tue Apr 16 18:21:10 2019
=================


//-----------------------------------------------------------
// 2019. STL 4.16 화 9 10                  (화목 7주/1일)
//
// 반복자의 정체는? - STL 반복자가 되려면 필요한 것들은?
// 
//   반복자 어댑터 - copy coding하며 설명
//   중간고사 - 4.25 목 9 10
//-----------------------------------------------------------

#include <iostream> 
#include <vector>
#include <list>
#include <forward_list>
#include <iterator>
#include "save.h"
#include "String.h"
using namespace std;      

// 반복자의 종류를 화면에 출력해보자
template <class Iter>
void cat(Iter);

class MyIter : public iterator<bidirectional_iterator_tag, String>{



};

int main()
{
   MyIter mi;

   cat(mi);
   
   save("2019 STL.cpp");
}

template <class Iter>
void cat(Iter iter)
{
   cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}







=================
Tue Apr 16 19:01:02 2019
=================


//-----------------------------------------------------------
// 2019. STL 4.16 화 9 10                  (화목 7주/1일)
//
// 반복자의 정체는? - STL 반복자가 되려면 필요한 것들은?
// 
//   반복자 어댑터 - copy coding하며 설명
//   중간고사 - 4.25 목 9 10
//-----------------------------------------------------------

#include <iostream> 
#include <vector>
#include <iterator>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;      

template<class InIter, class OutIter>
void DS_copy(InIter beg, InIter end, OutIter des);

int main()
{
   vector<String> v{3, 1, 4, 2, 5};
   vector<String> w;
   
   // copy 알고리즘으로 화면에 v의 원소를 모두 출력하라.
   //DS_copy(v.begin(), v.end(), ostream_iterator<String>(cout, "\n"));
   

   // DS_copy 알고리즘으로 v의 원소를 w에 복사하라.
   DS_copy(v.begin(), v.end(), back_inserter(w));         // w.begin()일때 w의 size는 바뀔 수 없음,  처음 가리키는 곳이 nullptr

   for (String& s : w)
      cout << s << endl;


   save("2019 STL.cpp");
}

template<class InIter, class OutIter>
void DS_copy(InIter beg, InIter end, OutIter des)
{
   while (beg != end) {
      *des++ = *beg++;
   }






===============
 Thu Apr 18 17:37:41 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	ostream_iterator <char> iter(cout);
	*iter = '*';
	save("main.cpp");
}






===============
 Thu Apr 18 17:38:04 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 2장. 순차 컨테이너 (Sequence Container)
// 원소의 순서를 마음대로 조작이 가능하다.
// - Array : [] 대신 항상 사용하자
// - Vector : dynamic Array
// - Deque
// - list
// - forword_list
//
// 반복자 어댑터 - copy coding하며 설명
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	ostream_iterator <char> iter(cout);
	*iter = '*';
	++iter;
	*iter = '&';
	save("main.cpp");
}






===============
 Thu Apr 18 17:51:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <vector>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	ostream_iterator <char> iter(cout);
	*iter = '*';
	++iter;
	*iter = '&';
	save("main.cpp");
}






===============
 Thu Apr 18 18:10:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	map<string, int> m;
	m.insert(pair<string,int>( "루피", 4'0000'0000 ));
	m.insert(make_pair("쵸파", 10));
	m.insert(make_pair("공부하기싫다", -500));
	m.insert(make_pair("집가고싶네", 40));
	m.insert(make_pair("배고프다", 60));
	m.insert(make_pair("밥사줄 밥먹을걸", 20));
	m.insert(make_pair("오늘저녁메뉴는", 90));
	m.insert(make_pair("샌드위치", 3456));
	m.insert(make_pair("샌드위치 버억", 3254));
	m.insert(make_pair("슬라이스햄 버억", 1253451));
	m.insert(make_pair("왓 더 버억", 514223));
	m.insert(make_pair("소떡소떡벅", 15324512));

	//map을 출력하자
	for (auto i : m)
	{
		cout << i.first << " " << i.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:14:13 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	map<string, int> m;
	m.insert(pair<string,int>( "루피", 4'0000'0000 ));
	m.insert(make_pair("쵸파", 10));
	m.insert(make_pair("공부하기싫다", -500));
	m.insert(make_pair("집가고싶네", 40));
	m.insert(make_pair("배고프다", 60));
	m.insert(make_pair("밥사줄 밥먹을걸", 20));
	m.insert(make_pair("오늘저녁메뉴는", 90));
	m.insert(make_pair("샌드위치", 3456));
	m.insert(make_pair("샌드위치 버억", 3254));
	m.insert(make_pair("슬라이스햄 버억", 1253451));
	m.insert(make_pair("왓 더 버억", 514223));
	m.insert(make_pair("소떡소떡벅", 15324512));

	//map을 출력하자
	for (const auto& i : m)
	{
		cout << "이름: " << i.first << ", 현상금: " << i.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:24:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	map<string, int> m;
	m.insert(pair<string,int>( "루피", 4'0000'0000 ));
	m.insert(make_pair("쵸파", 10));
	m.insert(make_pair("공부하기싫다", -500));
	m.insert(make_pair("집가고싶네", 40));
	m.insert(make_pair("배고프다", 60));
	m.insert(make_pair("밥사줄 밥먹을걸", 20));
	m.insert(make_pair("오늘저녁메뉴는", 90));
	m.insert(make_pair("샌드위치", 3456));
	m.insert(make_pair("샌드위치 버억", 3254));
	m.insert(make_pair("슬라이스햄 버억", 1253451));
	m.insert(make_pair("왓 더 버억", 514223));
	m.insert(make_pair("소떡소떡벅", 15324512));

	// 맵 m에서 루피를 찾아 현상그믈 20억으로 바꿔라
	auto p = m.find("루피");
	if (p != m.end())
	{
		p->second = 2000000000;
	}
	else
	{
		cout << "못찾아따리" << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:25:04 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	map<string, int> m;
	m.insert(pair<string,int>( "루피", 4'0000'0000 ));
	m.insert(make_pair("쵸파", 10));
	m.insert(make_pair("공부하기싫다", -500));
	m.insert(make_pair("집가고싶네", 40));
	m.insert(make_pair("배고프다", 60));
	m.insert(make_pair("밥사줄 밥먹을걸", 20));
	m.insert(make_pair("오늘저녁메뉴는", 90));
	m.insert(make_pair("샌드위치", 3456));
	m.insert(make_pair("샌드위치 버억", 3254));
	m.insert(make_pair("슬라이스햄 버억", 1253451));
	m.insert(make_pair("왓 더 버억", 514223));
	m.insert(make_pair("소떡소떡벅", 15324512));

	// 맵 m에서 루피를 찾아 현상그믈 20억으로 바꿔라
	auto p = m.find("루피");
	if (p != m.end())
	{
		p->second = 2000000000;
	}
	else
	{
		cout << "못찾아따리" << endl;
	}

	for (const auto& i : m)
	{
		cout << i.first << " " << i.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:27:16 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	map<string, int> m;
	m.insert(pair<string,int>( "루피", 4'0000'0000 ));
	m.insert(make_pair("쵸파", 10));
	m.insert(make_pair("공부하기싫다", -500));
	m.insert(make_pair("집가고싶네", 40));
	m.insert(make_pair("배고프다", 60));
	m.insert(make_pair("밥사줄 밥먹을걸", 20));
	m.insert(make_pair("오늘저녁메뉴는", 90));
	m.insert(make_pair("샌드위치", 3456));
	m.insert(make_pair("샌드위치 버억", 3254));
	m.insert(make_pair("슬라이스햄 버억", 1253451));
	m.insert(make_pair("왓 더 버억", 514223));
	m.insert(make_pair("소떡소떡벅", 15324512));

	// 맵 m에서 루피를 찾아 현상그믈 20억으로 바꿔라
	auto p = m.find("루피");
	if (p != m.end())
	{
		p->second = 2000000000;
	}
	else
	{
		cout << "못찾아따리" << endl;
	}

	m["루피"] = 30'0000'0000;
	m["김동순C?"] = 330'0000'0000;

	for (const auto& i : m)
	{
		cout << i.first << " " << i.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:34:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("main.cpp");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
		m[d]++;

	for (auto d : m)
	{
		cout << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:34:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("main.cpp");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
		m[d]++;

	for (auto d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:35:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("main.cpp");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
		m[d]++;

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:37:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("main.cpp");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:41:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("앨리스.txt");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:41:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("앨뤼스.txt");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:42:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("앨뤼스.txt");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:43:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("allice");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:43:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<char, int> m;
	ifstream in("allice.txt");

	vector<char> v{ istream_iterator<char>(in),istream_iterator<char>() };

	for (char d : v)
	{
		if (isalpha(d))
		{
			m[d]++;
		}
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Thu Apr 18 18:52:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<string, int> m;
	ifstream in("allice.txt");

	vector<string> v{ istream_iterator<string>(in),istream_iterator<string>() };

	for (string d : v)
	{
		m[d]++;
	}

	for (const auto& d : m)
	{
		cout << d.first << " " << d.second << endl;
	}

	cout << "모두" << m.size() << "단어가 사용되었습니다" << endl;

	save("main.cpp");
}






===============
 Thu Apr 18 18:56:32 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 소스.cpp에서 어떤 알파벳이 몇번 사용되었는지 출력해보자

int main()
{
	map<string, int> m;
	map<int, string> isMap;
	ifstream in("allice.txt");

	vector<string> v{ istream_iterator<string>(in),istream_iterator<string>() };

	for (string d : v)
	{
		m[d]++;
	}

	for (const auto& d : m)
	{
		isMap[d.second] = d.first;
	}

	for (const auto& d : isMap)
	{
		cout << d.first << " " << d.second << endl;
	}

	cout << "모두" << m.size() << "단어가 사용되었습니다" << endl;
	

	save("main.cpp");
}






===============
 Tue Apr 23 17:38:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("allice.txt");
	ofstream out("영문만 남긴 앨리스.txt");

	/*vector <char> v{ istreambuf_iterator<char>(in),istreambuf_iterator<char>() };

	replace_if(v.begin(), v.end(), [](const char& c) 
	{
		return !isalpha(c);
	}, ' ');*/

	replace_copy_if(istreambuf_iterator<char>(in), istreambuf_iterator<char>(), ostreambuf_iterator<char>(out), [](char c)
	{
		return !isalpha(c);
	}, ' ');

	save("main.cpp");
}






===============
 Tue Apr 23 17:45:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int> words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	//단어와 횟수를 출력해보자
	for (const auto d : words)
	{
		cout << d.first << endl;
	}

	save("main.cpp");
}






===============
 Tue Apr 23 17:46:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int> words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	//단어와 횟수를 출력해보자
	for (const auto d : words)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Tue Apr 23 17:56:36 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int> words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	// 가장 많이 사용된 단어 순으로 출력해보자
	/*for (const auto d : words)
	{
		cout << d.first << " " << d.second << endl;
	}*/

	multimap<int, string> mm;
	for (const auto& d : words)
	{
		mm.insert(make_pair(d.second, d.first));
	}

	for (auto iter = mm.rbegin(); iter != mm.rend(); ++iter)
	{
		cout << iter->first << " " << iter->second << endl;
	}

	save("main.cpp");
}






===============
 Tue Apr 23 18:00:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int> words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	// 가장 많이 사용된 단어 순으로 출력해보자
	vector<pair<string, int>> v{ words.begin(),words.end() };
	sort(v.begin(), v.end(), [](const auto& a,const auto& b)
	{
		return a.second > b.second;
	});

	for (const auto& d : v)
	{
		cout << d.first << " " << d.second << endl;
	}

	save("main.cpp");
}






===============
 Tue Apr 23 18:05:46 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int> words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	// 사용자가 입력한 단어의 사용 횟수를 알려주자
	// 없으면 없다고 알려주자
	string a;
	cin >> a;
	auto p = words.find(a);

	p != words.end() ? cout << p->second : cout << "없어요";

	save("main.cpp");
}






===============
 Tue Apr 23 18:24:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	// 사용자가 입력한 단어의 사용 횟수를 알려주자
	// 없으면 없다고 알려주자
	//while (true)
	{
		cout << " 찾으시는 단어를 입력해주세요: ";
		string a;
		cin >> a;
		auto p = words.find(a);

		p != words.end() ? cout << p->second << endl : cout << "없어요\n";
	}
	save("main.cpp");
}






===============
 Tue Apr 23 18:27:33 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

// 앨리스에서 알파벳이 아닌것은 공백으로 바꾸자
// 단어의 출현 횟수를 세자
// 사용자가 입력한 단어가 몇번 사용되었는지 출력하자

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}

	// words에 a로 시작하는 단어는 몇개일까
	int sum = count_if(words.begin(), words.end(), [](const pair<string,int>& a) 
	{
		return a.first[0] == 'a';
	});
	cout << sum << endl;
	 
	save("main.cpp");
}






===============
 Tue Apr 23 18:51:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

ostream& operator<< (ostream& os, const pair<string, int>&p)
{
	os << p.first << " " << p.second << endl;
}
int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}
	
	// map(횟수, 단어)로 만들자
	multimap<int, string> isMap;
	for (const pair<string, int>& d : words)
	{
		isMap.emplace(d.second, d.first);
	}

	size_t sum = count_if(isMap.begin(), isMap.end(),[](const pair<int, string>& d)
	{
		return d.first == 1;
	});

	cout << sum << endl;


	// 한번만 사용된 단어는 모두 몇개입니까?


	 
	save("main.cpp");
}






===============
 Tue Apr 23 18:54:15 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

ostream& operator<< (ostream& os, const pair<string, int>&p)
{
	os << p.first << " " << p.second << endl;
}
int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}
	
	// map(횟수, 단어)로 만들자
	multimap<int, string> isMap;
	for (const pair<string, int>& d : words)
	{
		isMap.emplace(d.second, d.first);
	}

	size_t sum = count_if(isMap.begin(), isMap.end(),[](const pair<int, string>& d)
	{
		return d.first == 1;
	});

	cout << sum << endl;

	// 같은 결과를 이렇게 얻을 수도 있다.
	auto b = isMap.upper_bound(1);
	auto e = isMap.upper_bound(2);


	cout << distance(b, e) << endl;


	 
	save("main.cpp");
}






===============
 Tue Apr 23 18:56:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

ostream& operator<< (ostream& os, const pair<string, int>&p)
{
	os << p.first << " " << p.second << endl;
}
int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}
	
	// map(횟수, 단어)로 만들자
	multimap<int, string> isMap;
	for (const pair<string, int>& d : words)
	{
		isMap.emplace(d.second, d.first);
	}

	size_t sum = count_if(isMap.begin(), isMap.end(),[](const pair<int, string>& d)
	{
		return d.first == 1;
	});

	cout << sum << endl;

	// 같은 결과를 이렇게 얻을 수도 있다.
	auto b = isMap.lower_bound(1);
	auto e = isMap.lower_bound(2);


	cout << distance(b, e) << endl;
	 
	save("main.cpp");
}






===============
 Tue Apr 23 18:58:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

ostream& operator<< (ostream& os, const pair<string, int>&p)
{
	os << p.first << " " << p.second << endl;
}
int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}
	
	// map(횟수, 단어)로 만들자
	multimap<int, string> isMap;
	for (const pair<string, int>& d : words)
	{
		isMap.emplace(d.second, d.first);
	}

	size_t sum = count_if(isMap.begin(), isMap.end(),[](const pair<int, string>& d)
	{
		return d.first == 1;
	});

	cout << sum << endl;

	// 같은 결과를 이렇게 얻을 수도 있다.
	//auto b = isMap.lower_bound(1);
	//auto e = isMap.lower_bound(2);
	auto p = isMap.equal_range(1);

	cout << distance(p.first, p.second) << endl;
	 
	save("main.cpp");
}






===============
 Thu May  2 17:29:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

ostream& operator<< (ostream& os, const pair<string, int>&p)
{
	os << p.first << " " << p.second << endl;
}
int main()
{
	ifstream in("영문만 남긴 앨리스.txt");

	//읽어서 단어와 출현횟수를 저장

	map<string, int, greater<string> > words;

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	while (beg != end)
	{
		words[*beg++]++;
	}
	
	// map(횟수, 단어)로 만들자
	multimap<int, string> isMap;
	for (const pair<string, int>& d : words)
	{
		isMap.emplace(d.second, d.first);
	}

	size_t sum = count_if(isMap.begin(), isMap.end(),[](const pair<int, string>& d)
	{
		return d.first == 1;
	});

	cout << sum << endl;

	// 같은 결과를 이렇게 얻을 수도 있다.
	//auto b = isMap.lower_bound(1);
	//auto e = isMap.lower_bound(2);
	auto p = isMap.equal_range(1);

	cout << distance(p.first, p.second) << endl;
	 
	save("main.cpp");
}






===============
 Thu May  2 17:34:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	// set에 정수를 몇개 넣어보자
	set<int> numbers{ 1,3,5,7,9,2,4,6,8,10 };

	for (auto iter = numbers.begin(); iter != numbers.end(); ++iter)
	{
		cout << *iter << endl;
	}

	save("main.cpp");
}






===============
 Thu May  2 17:34:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	// set에 정수를 몇개 넣어보자
	set<int> numbers{ 1,3,5,7,9,2,4,6,8,10 };

	for (auto iter = numbers.begin(); iter != numbers.end(); ++iter)
	{
		cout << *iter << endl;
	}

	save("main.cpp");
}






===============
 Thu May  2 17:49:16 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <algorithm>
#include <functional>


#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


int main()
{
	// set에 정수를 몇개 넣어보자
	// 이 set은 정수내림차순으로 정렬하면좋겠다.
	set<int, greater<int>> numbers{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = numbers.begin(); iter != numbers.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 17:53:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class X 
{
public:
	bool operator()(int a, int b) { return !(a < b); };
};

int main()
{
	// set에 정수를 몇개 넣어보자
	// 이 set은 정수내림차순으로 정렬하면좋겠다.
	set<int, X> numbers{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = numbers.begin(); iter != numbers.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 17:58:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class X 
{
public:
	bool operator()(String a, String b) { return !(a < b); };
};

int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String,X> strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 17:59:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class X 
{
public:
	bool operator()(String a, String b) { return !(a < b); };
};

int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String,X> strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 17:59:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class X 
{
public:
	bool operator()(String a, String b) { return (a < b); };
};

int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String,X> strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 18:03:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class 어캐하노 
{
public:
	bool operator()(String a, String b) { return (a < b); };
};

int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String,어캐하노> strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}

	/*for (const int d : numbers)
	{
		cout << d << endl;
	}*/

	save("main.cpp");
}






===============
 Thu May  2 18:14:43 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;


class 어캐하노 
{
public:
	bool operator()(String a, String b) { return (a < b); };
};

int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String > strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}


	save("main.cpp");
}






===============
 Thu May  2 18:17:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>

#include "Save.h"
#include "String.h"

using namespace std;

//uniform_int_distribution<int> myUID(1, 80);
//default_random_engine myDRE;

template<>
struct less<String>
{
	bool operator()(const String& a, const String& b)
	{
		return a.getNum() > b.getNum();
	}
};
int main()
{
	// set에 String을 몇개 넣어보자
	// 이 set은 string의 길이오름차순으로 정렬하면좋겠다.

	set<String,less<String> > strs{ 1,3,5,7,9,2,4,6,8,10 };
	

	for (auto iter = strs.begin(); iter != strs.end(); ++iter)
	{
		cout << *iter << endl;
	}


	save("main.cpp");
}






===============
 Thu May  2 18:23:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	random_device rd;
	default_random_engine dre{ rd() };
	uniform_int_distribution<> ui;

	for (int i = 0; i < 10;++i)
	{
		cout << ui(dre) << endl;
	}
	

	save("main.cpp");
}






===============
 Thu May  2 18:27:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('a','z');
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < 3; ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto d : s)
	{
		cout << d;
	}
	save("main.cpp");
}






===============
 Thu May  2 18:28:20 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('a','z');
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < 3; ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto d : s)
	{
		cout << d << endl;
	}
	save("main.cpp");
}






===============
 Thu May  2 18:29:17 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('a','z');
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < 3; ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto iter = s.begin(); iter!= s.end();++iter)
	{
		cout << *iter << "\t";
	}
	save("main.cpp");
}






===============
 Thu May  2 18:29:43 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('a','z');
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < 3; ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto iter = s.begin(); iter!= s.end();++iter)
	{
		cout << *iter << "\t";
	}
	cout << s.size() << endl;
	save("main.cpp");
}






===============
 Thu May  2 18:31:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('a','z');
	uniform_int_distribution<> uiLen(1, 3);
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < uiLen(dre); ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto iter = s.begin(); iter!= s.end();++iter)
	{
		cout << *iter << "\t";
	}
	cout << s.size() << endl;
	save("main.cpp");
}






===============
 Thu May  2 18:31:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('e','t');
	uniform_int_distribution<> uiLen(1, 3);
	set<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < uiLen(dre); ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	for (auto iter = s.begin(); iter!= s.end();++iter)
	{
		cout << *iter << "\t";
	}
	cout << s.size() << endl;
	save("main.cpp");
}






===============
 Thu May  2 18:40:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	
	default_random_engine dre{ 20190502 };
	uniform_int_distribution<> ui('e','t');
	uniform_int_distribution<> uiLen(1, 3);
	multiset<string> s;
	for (int i = 0; i < 3'0000;++i)
	{
		string str;
		for (int j = 0; j < uiLen(dre); ++j) // 26^3가지
		{
			str += ui(dre);
		}
		s.emplace(str);
	}
	
	/*for (auto iter = s.begin(); iter!= s.end();++iter)
	{
		cout << *iter << "\t";
	}*/
	
	//각 단어와 출현 횟수를 출력하시오

	for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i)) 
	{
		cout <<"[" <<*i << "] -> " << s.count(*i) << endl;
	}


	save("main.cpp");
}






===============
 Thu May  2 18:44:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");
	multiset<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	
	
	//각 단어와 출현 횟수를 출력하시오

	for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i)) 
	{
		cout <<"[" <<*i << "] -> " << s.count(*i) << endl;
	}


	save("main.cpp");
}






===============
 Thu May  2 18:48:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>
#include <fstream>
#include <iterator>
#include <map>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");
	multiset<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	
	
	//각 단어와 출현 횟수를 출력하시오

	/*for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i)) 
	{
		cout <<"[" <<*i << "] -> " << s.count(*i) << endl;
	}*/

	//단어 출현 횟수가 많은 순서대로 출력하자.

	multimap<int, string> mm;

	for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i))
	{
		mm.emplace(s.count(*i), *i);
	}

	for (auto i = mm.begin(); i != mm.end(); ++i)
	{
		cout << i->first << " " << i->second << endl;
	}

	save("main.cpp");
}






===============
 Thu May  2 18:48:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>
#include <fstream>
#include <iterator>
#include <map>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");
	multiset<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	
	
	//각 단어와 출현 횟수를 출력하시오

	/*for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i)) 
	{
		cout <<"[" <<*i << "] -> " << s.count(*i) << endl;
	}*/

	//단어 출현 횟수가 많은 순서대로 출력하자.

	multimap<int, string> mm;

	for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i))
	{
		mm.emplace(s.count(*i), *i);
	}

	for (auto i = mm.begin(); i != mm.end(); ++i)
	{
		cout << i->first << " " << i->second << endl;
	}

	cout << mm.size() << endl;

	save("main.cpp");
}






===============
 Thu May  2 18:55:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// associative container
// map : dictionary, {key:value}의 쌍이 원소
// set : key = value가 같은 원소
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <set>
#include <random>
#include <string>
#include <fstream>
#include <iterator>
#include <map>

#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	ifstream in("영문만 남긴 앨리스.txt");
	multiset<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	
	
	//각 단어와 출현 횟수를 출력하시오

	/*for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i)) 
	{
		cout <<"[" <<*i << "] -> " << s.count(*i) << endl;
	}*/

	//단어 출현 횟수가 많은 순서대로 출력하자.

	multimap<int, string> mm;

	for (auto i = s.begin(); i != s.end(); i = s.upper_bound(*i))
	{
		mm.emplace(s.count(*i), *i);
	}

	for (auto i = mm.rbegin(); i != mm.rend(); ++i)
	{
		cout << i->first << " " << i->second << endl;
	}

	cout << mm.size() << endl;

	save("main.cpp");
}






===============
 Tue May  7 17:42:25 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (const auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:45:23 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>



#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (const auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:48:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>



#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:48:28 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>



#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:48:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>



#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:48:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);

	//출력해보자
	for (auto& d : folks)
	{
		cout << d.first << " " << d.second << endl;
	}
	save("main.cpp");
}






===============
 Tue May  7 17:58:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// hash 함수의 출력값을 출력하자.
	cout << hash<string>()("Jan") << endl;
	cout << hash<string>()("Jim") << endl;
	cout << hash<string>()("Joe") << endl;

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:03:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < folks.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]" << endl;
	}

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:06:36 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_map<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks["Dan"] = 22;
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < folks.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (folks.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = folks.begin(i); iter != folks.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:09:14 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_multimap<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("DongSun", 29);
	folks.emplace("DongSuk", 29);
	folks.emplace("SuHyeon", 22);
	folks.emplace("Joe", 99);
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < folks.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (folks.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = folks.begin(i); iter != folks.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:09:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_multimap<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	//folks.emplace("DongSun", 29);
	//folks.emplace("DongSuk", 29);
	//folks.emplace("SuHyeon", 22);
	folks.emplace("Joe", 99);
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < folks.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (folks.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = folks.begin(i); iter != folks.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:09:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

// 임의의 소문자로 만든 단어 3만개가 있다.
// 단어의 빈도수를 출력하라

int main()
{
	unordered_multimap<string, int> folks;
	folks.insert(pair<string,int>( "Jan", 44 ));
	folks.insert(make_pair("Jim", 33));
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	folks.emplace("Joe", 99);
	//folks.emplace("DongSun", 29);
	//folks.emplace("DongSuk", 29);
	//folks.emplace("SuHyeon", 22);
	folks.emplace("Joe", 99);
	folks.emplace_hint(folks.begin(), "Ann", 55);
	folks.emplace_hint(folks.begin(), "Ann", 55);
	folks.emplace_hint(folks.begin(), "Ann", 55);
	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < folks.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (folks.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = folks.begin(i); iter != folks.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	//출력해보자
	//for (auto& d : folks)
	//{
	//	cout << d.first << " " << d.second << endl;
	//}
	save("main.cpp");
}






===============
 Tue May  7 18:39:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>


#include "Save.h"
#include "String.h"

using namespace std;

template<>
struct hash<String>
{
	int operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}

};

// 두 객체가 같다?
// map에서는 a, b 객체가 같다는 판단을 
// !(a < b) && !(b<a) -> 두 객체는 같다. 동등(equivalence)
// !(3 < 3) && ! (3<3)
// unordered_map은 < 연산자는 무의미하다
// ==연산자로 같음을 판단한다. 상등(equality)

int main()
{
	//unordered_multimap<String, string> folks;
	//folks.emplace(10, "10글자");
	//folks.emplace(15, "15글자");
	//folks.emplace(20, "20글자");
	//folks.emplace(13, "13글자");
	//folks.emplace(16, "16글자");
	//folks.emplace(23, "23글자");

	//
	//// unordered_map의 구조를 출력해보자
	//
	//for (int i = 0; i < folks.bucket_count(); ++i)
	//{
	//	//[i] - 원소 ; 세로는 벡터 가로는 리스트
	//	cout << "[" << i << "]";
	//	if (folks.bucket_size(i))
	//	{
	//		cout << " - ";
	//		for (auto iter = folks.begin(i); iter != folks.end(i); ++iter)
	//		{
	//			cout << iter->second << " ";
	//		}

	//	}
	//	cout << endl;
	//}


	save("main.cpp");
}






===============
 Wed May  8 15:56:14 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>
#include <ctime>


#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	int operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}


	
};

class Dog
{
	string name;
	
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() {
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const 
	{
		hash<string> h;
		return h(d.getName());
	}
};
// 두 객체가 같다?
// map에서는 a, b 객체가 같다는 판단을 
// !(a < b) && !(b<a) -> 두 객체는 같다. 동등(equivalence)
// !(3 < 3) && ! (3<3)
// unordered_map은 < 연산자는 무의미하다
// ==연산자로 같음을 판단한다. 상등(equality)

int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");

	

	
	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:00:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>
#include <ctime>


#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	int operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}


	
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() {
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		hash<string> h;
		return h(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");

	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:01:18 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>
#include <ctime>


#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	int operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}


	
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() {
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		hash<string> h;
		return h(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:02:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>
#include <map>
#include <ctime>


#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	int operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}


	
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() {
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		hash<string> h;
		return h(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:08:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	size_t operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:09:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	size_t operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}

	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:10:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////


#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

struct myhash
{
	size_t operator() (const String& a) const 
	{
		return hash<char*>() (a.getData());
	}
};

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	/*dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}

		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:11:28 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (Dog d) const // 왜 멤버인자로 const와 레퍼런스를 사용할 수 없는가
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}
		}
		cout << endl;
	}

	save("main.cpp");
}






===============
 Wed May  8 16:20:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}
		}
		cout << endl;
	}

	save("main.cpp");
}




===============
 Thu May  9 18:23:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	size_t operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	/*dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}
		}
		cout << endl;
	}

	save("main.cpp");
}




===============
 Thu May  9 18:24:14 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	size_t operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	/*dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}
		}
		cout << endl;
	}

	save("main.cpp");
}




===============
 Thu May  9 18:24:34 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// unordered associative container
// unordered_map : {key:value}의 쌍이 원소 (해쉬 밸류를 사용)
// undrdered_set
//
// 내가 클래스를 설계하고 객체를 수 만개 이상 만들어서 컨테이너에 넣고 
// 필요한 동작을 연습해봅시다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(string n) :name(n) {}
	bool operator== (Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	size_t operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");

	// unordered_map의 구조를 출력해보자
	
	for (unsigned int i = 0; i < dogs.bucket_count(); ++i)
	{
		//[i] - 원소 ; 세로는 벡터 가로는 리스트
		cout << "[" << i << "]";
		if (dogs.bucket_size(i))
		{
			cout << " - ";
			for (auto iter = dogs.begin(i); iter != dogs.end(i); ++iter)
			{
				cout << iter->second << " ";
			}
		}
		cout << endl;
	}

	save("main.cpp");
}




===============
 Tue May 14 17:46:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	Dog(const string n) : name(n) {}
	Dog(const char* n) : name(n) {}

	bool operator== (const Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	/*dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	// "별이"라는 이름의 개를 찾아 있다면 어떤 품종인지 출력하라

	auto p = dogs.find("별이");
	if (p != dogs.end())
	{
		cout << p->second << "입니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 14 17:48:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	template <class T>
	Dog(T n) : name(n) {}
	//Dog(const char* n) : name(n) {}

	bool operator== (const Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_multimap<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	/*dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	// "별이"라는 이름의 개를 찾아 있다면 어떤 품종인지 출력하라

	auto p = dogs.find("별이"); //char* 형태이다(string이아니다)
	if (p != dogs.end())
	{
		cout << p->second << "입니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 14 17:50:23 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_map>

#include "Save.h"
#include "String.h"

using namespace std;

class Dog
{
	string name;
public:
	template <class T>
	Dog(T n) : name(n) {}
	//Dog(const char* n) : name(n) {}

	bool operator== (const Dog d) const
	{
		return name == d.name;
	}
	string getName() const
	{
		return name;
	}
};

struct DogHash
{
	int operator() (const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};


int main()
{
	unordered_map<Dog, string, DogHash> dogs;

	dogs.emplace("별이", "진돗개");
	dogs.emplace("콩이", "풍산개");
	/*dogs.emplace("달이", "달개");
	dogs.emplace("게이", "게개");
	dogs.emplace("성이", "성개");
	dogs.emplace("하이", "하개");
	dogs.emplace("야이", "야개");
	dogs.emplace("호이", "호개");
	dogs.emplace("소이", "소개");
	dogs.emplace("분이", "분개");*/

	// unordered_map의 구조를 출력해보자
	
	// "별이"라는 이름의 개를 찾아 있다면 어떤 품종인지 출력하라

	cout << dogs["별이"] << "입니다" << endl;

	save("main.cpp");
}




===============
 Tue May 14 18:03:15 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}

	cout << m.size() << endl;
	cout << i << endl;
	save("main.cpp");
}




===============
 Tue May 14 18:06:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;
	save("main.cpp");
}




===============
 Tue May 14 18:12:16 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 임의의 값 백만개를 찾고 시간을 잰다

	using namespace std::chrono; // 시간이 걸리는 코드

	auto b = chrono::steady_clock::now();

	for (int i = 0; i < 100'0000; ++i)
	{
		m[uid(dre)];
	}
	cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
	cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;

	save("main.cpp");
}




===============
 Tue May 14 18:16:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 임의의 값 백만개를 찾고 시간을 잰다

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			m[uid(dre)];
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			um[uid(dre)];
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:20:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100'0000);
	for (int i = 0; i < 100'0000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백만개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			m[v[i]];
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			um[v[i]];
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:22:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100'0000);
	for (int i = 0; i < 100'0000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백만개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:23:44 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천만개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end()};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100'0000);
	for (int i = 0; i < 100'0000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백만개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10'0000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10'0000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백만개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:26:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천만개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),1000};
	
	cout << "언오더드 맵에 정수 천만개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100);
	for (int i = 0; i < 100; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<milliseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:26:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 1000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 천개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),1000};
	
	cout << "언오더드 맵에 정수 천개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100);
	for (int i = 0; i < 100; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 100; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:30:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 10'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 100000개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),100000};
	
	cout << "언오더드 맵에 정수 100000개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(100);
	for (int i = 0; i < 10000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:31:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 10'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 100000개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),100000};
	
	cout << "언오더드 맵에 정수 100000개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(10'0000);
	for (int i = 0; i < 10000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:31:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 10'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 100000개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),100000};
	
	cout << "언오더드 맵에 정수 100000개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(1'0000);
	for (int i = 0; i < 10000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 백개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:32:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// 맵과 언오더드맵의 찾기실력을 비교한다.
// 1000'0000를 갖는 맵과 언오더드맵을 생성한다.
// 임의의 100'0000개의 원소를 찾아본다

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;
	// 임의의 정수 천개를 map에 담는다
	map<int, int> m;
	int i = 0;
	while (m.size() != 10'0000)
	{
		m.emplace(uid(dre), ++i);
	}
	cout << "맵에 정수 100000개 생성 - " << m.size() << endl;
	// 언오더드 맵에 맵의 원소들을 복사한다
	unordered_map<int, int> um { m.begin(), m.end(),100000};
	
	cout << "언오더드 맵에 정수 100000개 복사 - " << um.size() << endl;

	// 벡터에 찾을 임의의 값 백만개를 생성하자
	vector<int> v;
	v.reserve(1'0000);
	for (int i = 0; i < 10000; ++i)
	{
		v.emplace_back(uid(dre));
	}

	cout << "찾을 값 백개를 벡터에 생성하였다" << endl;

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		cout << "맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			m.find(v[i]);
		}
		cout << "맵에서 10000개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		cout << "언오더드 맵의 찾기 실력 측정중" << endl;
		auto b = chrono::steady_clock::now();

		for (int i = 0; i < 10000; ++i)
		{
			um.find(v[i]);
		}
		cout << "맵에서 10000개 원소를 찾는데 걸린 시간 - ";
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}
	save("main.cpp");
}




===============
 Tue May 14 18:44:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

class X
{
public:
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v;
	v.reserve(1000);
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),X()); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	for (int d : v)
	{
		cout << d << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 14 18:45:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

class X
{
public:
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v;
	v.reserve(1000);
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),X()); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	for (int d : v)
	{
		cout << d << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 14 18:46:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

class X
{
public:
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v(1000);
	
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),X()); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	for (int d : v)
	{
		cout << d << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 14 18:47:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

class X
{
public:
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v(10000000);
	
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),X()); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "밀리초 경과" << endl;
	}

	
	
	save("main.cpp");
}




===============
 Tue May 14 18:48:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

class X
{
public:
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v(10000000);
	
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "마이크로초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),X()); // 매우빠른
		cout << (duration_cast<microseconds>(steady_clock::now() - b).count()) << "마이크로초 경과" << endl;
	}

	
	
	save("main.cpp");
}




===============
 Tue May 14 18:50:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

bool cmp(int a, int b)
{

	return a > b;
}

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v(10000000);
	
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout <<"람다식 걸린 시간 - " <<
			(duration_cast<microseconds>(steady_clock::now() - b).count()) << " 마이크로초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),cmp); // 매우빠른
		cout << "함수 객체 걸린 시간 - " << (duration_cast<microseconds>(steady_clock::now() - b).count()) << " 마이크로초 경과" << endl;
	}

	
	
	save("main.cpp");
}




===============
 Tue May 14 18:53:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>
#include <vector>
#include <chrono>
#include <random>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

inline bool cmp(int a, int b)
{

	return a > b;
}

// sort에 걸리는 시간을 재 본다.

int main()
{
	vector<int> v(10000000);
	
	iota(v.begin(), v.end(), 1);

	

	using namespace std::chrono; // 시간이 걸리는 코드
	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(), [](int a, int b) { return a > b; }); // 매우빠른
		cout <<"람다식 걸린 시간 - " <<
			(duration_cast<microseconds>(steady_clock::now() - b).count()) << " 마이크로초 경과" << endl;
	}

	{
		auto b = chrono::steady_clock::now();
		random_shuffle(v.begin(), v.end());

		sort(v.begin(), v.end(),cmp); // 매우빠른
		cout << "함수 객체 걸린 시간 - " << (duration_cast<microseconds>(steady_clock::now() - b).count()) << " 마이크로초 경과" << endl;
	}

	
	
	save("main.cpp");
}




===============
 Thu May 16 17:39:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 연관 컨테이너의 찾기에 걸리는 시간을 재 본다
//
// 컨테이너와 반복자의 속을 들여다 본다
// 알고리즘 함수를 알아보고 만들어 본다
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	cout << s << endl;

	for (auto i = s.begin(); i != s.end(); ++i)
	{
		cout << *i;
	}
	cout << endl;
	save("main.cpp");
}




===============
 Thu May 16 17:46:10 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	cout << s << endl;

	for (auto i = s.begin(); i != s.end(); ++i)
	{
		cout << *i;
	}
	cout << endl;
	save("main.cpp");
}




===============
 Thu May 16 17:47:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	cout << s << endl;

	for (char c : s)
	{
		cout << c;
	}
	cout << endl;
	cout << endl;
	save("main.cpp");
}




===============
 Thu May 16 18:20:24 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	cout << s << endl;

	for (char c : s)
	{
		cout << c;
	}
	cout << endl;

	//이때 rbegin의 위치는 end()위치와 같다
	//rend() 위치는 begin()과 같다
	for (auto i = s.rbegin(); i != s.rend(); ++i)
	{
		cout << *i;
	}
	cout << endl;

	save("main.cpp");
}




===============
 Thu May 16 18:22:06 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	
	sort(s.begin(), s.end());

	save("main.cpp");
}




===============
 Thu May 16 18:22:18 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	
	sort(s.begin(), s.end());
	cout << s << endl;
	save("main.cpp");
}




===============
 Thu May 16 19:00:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
///////////////////////////////////////////////////////////////////////

#include <iostream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(30);
	
	sort(s.begin(), s.end());
	cout << s << endl;
	save("main.cpp");
}




===============
 Tue May 21 17:25:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// String.h - 소문자를 랜덤하게 HEAP에 할당한다
// 이 class는 이동을 지원한다
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	String s(100);
	sort(s.begin(), s.end());
	cout << s << endl;
	save("main.cpp");
}




===============
 Tue May 21 17:28:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	vector<int> v;

	// 키보드에서 읽은 정수를 벡터 v에 넣어라
	
	copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
	for (int d : v)
	{
		cout << d << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 17:29:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	vector<int> v;

	// 키보드에서 읽은 정수를 벡터 v에 넣어라
	
	copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
	for (int d : v)
	{
		cout << d << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 17:47:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

template <class InIter,class OutIter>
void myCopy(InIter beg, InIter end, OutIter out)
{
	while (beg != end)
	{
		*out++ = *beg++;
	}
}




int main()
{
	vector<int> v;

	// 키보드에서 읽은 정수를 벡터 v에 넣어라
	
	myCopy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
	for (int d : v)
	{
		cout << d << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 17:58:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

template <class InIter,class OutIter>
void myCopy(InIter beg, InIter end, OutIter out)
{
	while (beg != end)
	{
		*out = *beg++; // *(out).operator=(int)
		++out;
	}
}

class b_i
{
	vector<int>& v;
public:
	b_i(vector<int>& v) : v{ v } {};

	b_i& operator*() { return *this; }
	void operator++() {}
	void operator=(int n) 
	{
		v.push_back(n);
	}
};



int main()
{
	vector<int> v;

	// 키보드에서 읽은 정수를 벡터 v에 넣어라
	
	myCopy(istream_iterator<int>(cin), istream_iterator<int>(), b_i(v));
	for (int d : v)
	{
		cout << d << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:13:04 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	string s{ "C++ STL: Standard Template Library!" };
	auto p = find(s.begin(), s.end(), '!');

	if (p != s.end())
	{
		cout << distance(s.begin(),p) + 1 << "에 있다" << endl;
	}
	else
	{
		cout << "!를 못찾았습니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:13:23 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

int main()
{
	string s{ "!C++ STL: Standard Template Library!" };
	auto p = find(s.begin(), s.end(), '!');

	if (p != s.end())
	{
		cout << distance(s.begin(),p) + 1 << "에 있다" << endl;
	}
	else
	{
		cout << "!를 못찾았습니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:17:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter>
Iter myfind(Iter beg, Iter end, char c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
	}
	return end;
}

int main()
{
	string s{ "!C++ STL: Standard Template Library!" };
	auto p = myfind(s.begin(), s.end(), '!');

	if (p != s.end())
	{
		cout << distance(s.begin(),p) + 1 << "에 있다" << endl;
	}
	else
	{
		cout << "!를 못찾았습니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:19:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter>
Iter myfind(Iter beg, Iter end, char c)
{
	while (beg != end)
	{
		if (*beg++ == c)
		{
			return beg;
		}
	}

	return end;
}

int main()
{
	string s{ "!C++ STL: Standard Template Library!" };
	auto p = myfind(s.begin(), s.end(), '*');

	if (p != s.end())
	{
		cout << distance(s.begin(),p) + 1 << "에 있다" << endl;
	}
	else
	{
		cout << "!를 못찾았습니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:26:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter, class Val>
Iter myfind(Iter beg, Iter end, Val c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
		else
		{
			++beg;
		}
	}

	return end;
}

int main()
{
	string s{ "C++ STL: Standard Template Library!" };
	auto p = myfind(s.begin(), s.end(), '*');

	if (p != s.end())
	{
		cout << distance(s.begin(),p) + 1 << "에 있다" << endl;
	}
	else
	{
		cout << "!를 못찾았습니다" << endl;
	}

	save("main.cpp");
}




===============
 Tue May 21 18:29:32 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter, class Val>
Iter myfind(Iter beg, Iter end, Val c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
		else
		{
			++beg;
		}
	}

	return end;
}

int main()
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// v에 홀수가 몇개 있는지 찾아보자

	auto n = count_if(v.begin(), v.end(), [](int a) {return a % 2 != 0; });
	cout << n << "개입니다" << endl;

	save("main.cpp");
}




===============
 Tue May 21 18:34:26 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter, class Val>
Iter myfind(Iter beg, Iter end, Val c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
		else
		{
			++beg;
		}
	}

	return end;
}
template <class Iter, class Lam>
size_t my_count_if(Iter beg, Iter end, Lam lam)
{
	int count = 0;
	while (beg != end)
	{
		if (lam(*beg))
		{
			++count;
		}
		++beg;
	}

	return count;
}

int main()
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// v에 홀수가 몇개 있는지 찾아보자

	size_t n = my_count_if(v.begin(), v.end(), [](int a) -> bool {return a & 1; });

	cout << n << "개입니다" << endl;

	save("main.cpp");
}




===============
 Tue May 21 18:47:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter, class Val>
Iter myfind(Iter beg, Iter end, Val c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
		else
		{
			++beg;
		}
	}

	return end;
}

template <class Iter, class CallableType>
size_t my_count_if(Iter beg, Iter end, CallableType pred)
{
	size_t count = 0;
	while (beg != end)
	{
		if (pred(*beg))
		{
			++count;
		}
		++beg;
	}

	return count;
}

bool X(int n) { return n & 1; }

int main()
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// v에 홀수가 몇개 있는지 찾아보자

	size_t n = my_count_if(v.begin(), v.end(),X); // predicate - bool 값을 리턴하는 함수

	cout << n << "개입니다" << endl;

	save("main.cpp");
}




===============
 Tue May 21 18:48:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;

template<class Iter, class Val>
Iter myfind(Iter beg, Iter end, Val c)
{
	while (beg != end)
	{
		if (*beg == c)
		{
			return beg;
		}
		else
		{
			++beg;
		}
	}

	return end;
}

template <class Iter, class CallableType>
size_t my_count_if(Iter beg, Iter end, CallableType pred)
{
	size_t count = 0;
	while (beg != end)
	{
		if (pred(*beg))
		{
			++count;
		}
		++beg;
	}

	return count;
}

//bool X(int n) { return n & 1; }

class X
{
public:
	bool operator()(int n)
	{
		return n & 1;
	}
};

int main()
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// v에 홀수가 몇개 있는지 찾아보자

	size_t n = my_count_if(v.begin(), v.end(),X()); // predicate - bool 값을 리턴하는 함수

	cout << n << "개입니다" << endl;

	save("main.cpp");
}




===============
 Tue May 21 18:59:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 10,20,10,20,30,10,20,30,40 };
	vector<String> v1{ v };
	vector<String> v2{ v };
	
	// v1을 sort한 후 출력하자

	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << endl;
	}

	// v2를 stable_sort한 후 출력하라
	save("main.cpp");
}




===============
 Tue May 21 19:00:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 10,20,10,20,30,10,20,30,40 };
	vector<String> v1{ v };
	vector<String> v2{ v };
	
	// v1을 sort한 후 출력하자

	sort(v1.begin(), v1.end());
	cout << "그냥 정렬" << endl;
	for (const String& s : v1)
	{
		cout << s << endl;
	}

	// v2를 stable_sort한 후 출력하라
	stable_sort(v1.begin(), v1.end());
	cout << "stable정렬" << endl;
	for (const String& s : v1)
	{
		cout << s << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:28:31 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 17:32:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	save("main.cpp");
}




===============
 Thu May 23 17:35:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 17:37:25 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << "정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:38:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,3,1,5,3,1,3,5,4,6,8 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << "정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:38:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,3,1,5,3,1,3,5,4,6,8,10,13,79,1,3,64,1,1,1,1,3,3,3,5,5,5,7,9,5,4,3,2,1,6,5 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << "정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:40:02 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 10,9,8,7,6,5,4,3,2,1};
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << "정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:41:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:41:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:41:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:41:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		-
//		partial_sort	-
//		nth_element		-
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<String> v{ 5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 ,
	5,5,5,5,5,3,3,3,3,3,1,1,1,1,1,5,5,5,5,5,3,3,3,3,3,1,1,1,1,1 };
	vector<String> v1(v);
	vector<String> v2(v);
	cout << "원본 데이터" << endl;
	for (const String& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "길이 오름차순으로 sort" << endl;
	sort(v1.begin(), v1.end());

	for (const String& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "길이 오름차순으로 stable_sort" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const String& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:53:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v;
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	sort(v1.begin(), v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "10등과 나머지 구분 nth_element" << endl;
	stable_sort(v2.begin(), v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:55:59 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(30);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 10, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "10등과 나머지 구분 nth_element" << endl;
	//nth_element(v1.begin(),)

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	if (equal(v1.begin(), v1.end(), v2.begin()))
	{
		cout << endl <<"정렬 결과 두 방법은 같다" << endl;
	}
	else
	{
		cout << endl << "결과가 다르다 " << endl;
	}

	save("main.cpp");
}




===============
 Thu May 23 17:57:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 10, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << "10등과 나머지 구분 nth_element" << endl;
	nth_element(v2.begin(), v2.begin() + 10, v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 17:57:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 10, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << endl<<"10등과 나머지 구분 nth_element" << endl;
	nth_element(v2.begin(), v2.begin() + 10, v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 17:58:32 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 10, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << endl<<"10등과 나머지 구분 nth_element" << endl;
	nth_element(v2.begin(), v2.begin() + 10, v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 17:59:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(200);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 10, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << endl<<"10등과 나머지 구분 nth_element" << endl;
	nth_element(v2.begin(), v2.begin() + 10, v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:01:48 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(200);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	//v를 원하는 갯수
	vector<int> v1(v);
	vector<int> v2(v);
	cout << "원본 데이터" << endl;
	for (const int& s : v)
	{
		cout << s << "\t";
	}

	cout << endl << endl;

	// v1을 글자의 길이 순으로 sort하여 출력한다.

	cout << endl << "10등까지 partial_sort" << endl;
	partial_sort(v1.begin(), v1.begin() + 20, v1.end());

	for (const int& s : v1)
	{
		cout << s << "\t";
	}
	// v2을 글자의 길이 순으로 stable_sort하여 출력한다.

	cout << endl<<"10등과 나머지 구분 nth_element" << endl;
	nth_element(v2.begin(), v2.begin() + 20, v2.end());

	for (const int& s : v2)
	{
		cout << s << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:03:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(200);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	save("main.cpp");
}




===============
 Thu May 23 18:06:16 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(200);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	save("main.cpp");
}




===============
 Thu May 23 18:11:33 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	vector<int> v2(v); 
	vector<int> v3(v1.size()+v2.size());

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());

	for (int d : v3)
	{
		cout << d << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:11:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	vector<int> v2(v); 
	vector<int> v3(v1.size()+v2.size());

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin());

	for (int d : v3)
	{
		cout << d << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:14:53 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	vector<int> v2(v); 
	vector<int> v3;

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(),back_inserter(v3));

	for (int d : v3)
	{
		cout << d << "\t";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:16:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	for (int d : v1)
	{
		cout << d << " ";
	}
	vector<int> v2(v); 
	for (int d : v2)
	{
		cout << d << " ";
	}
	vector<int> v3;

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(),back_inserter(v3));

	for (int d : v3)
	{
		cout << d << " ";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:17:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	for (int d : v1)
	{
		cout << d << " ";
	}
	cout << endl;
	vector<int> v2(v); 
	for (int d : v2)
	{
		cout << d << " ";
	}
	cout << endl;
	vector<int> v3;

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(),back_inserter(v3));

	for (int d : v3)
	{
		cout << d << " ";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:17:22 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(20);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	//sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;


	vector<int> v1(v);
	for (int d : v1)
	{
		cout << d << " ";
	}
	cout << endl;
	vector<int> v2(v); 
	for (int d : v2)
	{
		cout << d << " ";
	}
	cout << endl;
	vector<int> v3;

	cout << "v1과 v2를 v3로 merge" << endl;
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(),back_inserter(v3));

	for (int d : v3)
	{
		cout << d << " ";
	}

	save("main.cpp");
}




===============
 Thu May 23 18:21:19 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라
	if (find(v.begin(), v.end(), 77777) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}

	

	save("main.cpp");
}




===============
 Thu May 23 18:24:45 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 777) << endl;

	// 빵점
	if (find(v.begin(), v.end(), 7777) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}

	

	save("main.cpp");
}




===============
 Thu May 23 18:27:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 7777).second << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:28:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 7777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:29:20 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << equal_range(v.begin(), v.end(), 7777).second - equal_range(v.begin(), v.end(), 7777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:29:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 77777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:30:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 77777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:30:47 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 7777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:30:54 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 77777).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:31:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	//if (find(v.begin(), v.end(), 7777) != v.end())
	//{
	//	cout << "있다" << endl;
	//}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 0).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:31:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	//else
	//{
	//	cout << "없다" << endl;
	//}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	//cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 0).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:31:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	//cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 0).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:31:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << *equal_range(v.begin(), v.end(), 0).first << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:32:33 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << equal_range(v.begin(), v.end(), 0).first - v.begin() << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:32:41 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << equal_range(v.begin(), v.end(), 7777).first - v.begin() << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:33:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << equal_range(v.begin(), v.end(), 7777).second - v.begin() << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:36:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	cout << "7777의 위치" << equal_range(v.begin(), v.end(), 123456).first - v.begin() << endl;

	

	save("main.cpp");
}




===============
 Thu May 23 18:37:55 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	auto p = equal_range(v.begin(), v.end(), 123456);
	if (p.first != p.second)
	{
		cout << p.first - v.begin() << "에 있습니다";
	}
	else
	{
		cout << "없음" << endl;
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:38:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	auto p = equal_range(v.begin(), v.end(), 7777);
	if (p.first != p.second)
	{
		cout << p.first - v.begin() << "에 있습니다";
	}
	else
	{
		cout << "없음" << endl;
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:40:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	auto p = equal_range(v.begin(), v.end(), 7777);
	if (p.first != p.second)
	{
		for (auto i = p.first; i != p.second; ++i)
		{
			cout << *i << " - " << distance(v.begin(), i) + 1 << endl;
		}
	}
	else
	{
		cout << "없음" << endl;
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:41:13 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted
//		merge
//		binary_search	
//		equal_range
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	v[0] = 7777;
	v[1] = 7777;
	v[2] = 7777;
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	auto p = equal_range(v.begin(), v.end(), 7777);
	if (p.first != p.second)
	{
		for (auto i = p.first; i != p.second; ++i)
		{
			cout << *i << " - " << distance(v.begin(), i) + 1 << endl;
		}
	}
	else
	{
		cout << "없음" << endl;
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:43:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합, 검색, 분리
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(10000);
	iota(v.begin(), v.end(), 1);
	random_shuffle(v.begin(), v.end());
	v[0] = 7777;
	v[1] = 7777;
	v[2] = 7777;
	sort(v.begin(), v.end());

	cout << "v는 정렬되었나?: " << boolalpha << is_sorted(v.begin(), v.end()) << endl;;

	// v에 7777이 있나 알고 싶다. 해 봐라


	// cout << "7777 " << boolalpha << binary_search(v.begin(), v.end(), 7777) << endl;

	// 빵점
	/*if (find(v.begin(), v.end(), 0) != v.end())
	{
		cout << "있다" << endl;
	}
	else
	{
		cout << "없다" << endl;
	}*/

	// v에 7777이 있나 찾고 어디에 있는지 출력한다.
	auto p = equal_range(v.begin(), v.end(), 7777);
	if (p.first != p.second)
	{
		for (auto i = p.first; i != p.second; ++i)
		{
			cout << *i << " - " << distance(v.begin(), i) + 1 << endl;
		}
	}
	else
	{
		cout << "없음" << endl;
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:51:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});
	

	save("main.cpp");
}




===============
 Thu May 23 18:53:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	for (int d : v)
	{
		cout << d << " ";
	}
	

	save("main.cpp");
}




===============
 Thu May 23 18:55:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	for (int i=0;i<v.size();++i)
	{
		if (v[i] == 50)
		{
			cout << "50발견 - " << i + 1 << endl;
		}
	}
	
	
	save("main.cpp");
}




===============
 Thu May 23 18:59:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	auto vIter = v.begin();
	while (vIter != v.end())
	{
		vIter = find(vIter+1, v.end(), 50);
		if (vIter != v.end())
		{
			cout << "위치-" << distance(v.begin(), vIter) << endl;
		}


	}

	//for (int i=0;i<v.size();++i)
	//{
	//	if (v[i] == 50)
	//	{
	//		cout << "50발견 - " << i + 1 << endl;
	//	}
	//}
	
	
	save("main.cpp");
}




===============
 Tue May 28 17:23:11 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	auto vIter = v.begin();
	while (vIter != v.end())
	{
		vIter = find(vIter+1, v.end(), 50);
		if (vIter != v.end())
		{
			cout << "위치-" << distance(v.begin(), vIter) << endl;
		}
	}

	//for (int i=0;i<v.size();++i)
	//{
	//	if (v[i] == 50)
	//	{
	//		cout << "50발견 - " << i + 1 << endl;
	//	}
	//}
	
	
	save("main.cpp");
}




===============
 Tue May 28 17:33:55 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	auto vIter = v.begin();
	while (vIter != v.end())
	{
		vIter = find(vIter, v.end(), 50);
		if (vIter != v.end())
		{
			cout << "위치 - " << distance(v.begin(), vIter) + 1 << endl;
			++vIter;
		}
	}
	
	
	save("main.cpp");
}




===============
 Tue May 28 17:34:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_of
//		find_first_of
//		adjacent_find
//		find_end
//		search
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000);
	
	default_random_engine dre;
	uniform_int_distribution<> uid(1, 100);

	for_each(v.begin(), v.end(), [&](int& n) {
		n = uid(dre);
	});

	auto vIter = v.begin();
	while (vIter != v.end())
	{
		vIter = find(vIter, v.end(), 50);
		if (vIter != v.end())
		{
			cout << "위치 - " << distance(v.begin(), vIter) << endl;
			++vIter;
		}
	}
	
	
	save("main.cpp");
}




===============
 Tue May 28 17:42:21 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//		find_end
//
//		search
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };
	
	vector<int> vf{ 2,3,5,7,11,13,17 };

	auto p = find_first_of(v.begin(), v.end(), vf.begin(), vf.end());
	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서 소수 발견" << endl;
	}
	else
	{
		cout << "v에 소수는 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:47:01 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7 };
	
	vector<int> vf{ 2,3,5 };

	auto p = search(v.begin(), v.end(), vf.begin(), vf.end());
	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서  발견" << endl;
	}
	else
	{
		cout << "v에 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:47:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7 };
	
	vector<int> vf{ 2,3,4 };

	auto p = search(v.begin(), v.end(), vf.begin(), vf.end());
	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서  발견" << endl;
	}
	else
	{
		cout << "v에 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:48:04 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7 };
	
	vector<int> vf{ 2,3,4 };

	auto p = search(v.begin(), v.end(), vf.begin(), vf.end());
	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서  발견" << endl;
	}
	else
	{
		cout << "v에 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:48:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7 };
	
	vector<int> vf{ 2,3,4 };

	auto p = find_end(v.begin(), v.end(), vf.begin(), vf.end());

	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서  발견" << endl;
	}
	else
	{
		cout << "v에 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:49:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7,2,3,4 };
	
	vector<int> vf{ 2,3,4 };

	auto p = find_end(v.begin(), v.end(), vf.begin(), vf.end());

	if (p != v.end())
	{
		cout << distance(v.begin(), p) + 1 << "에서  발견" << endl;
	}
	else
	{
		cout << "v에 없네요" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:52:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,7,2,3,4 };
	
	auto p = adjacent_find(v.begin(), v.end());

	if (p != v.end())
	{
		cout << "위치 - " << distance(v.begin(), p) +1 << endl;
	}
	else
	{
		cout << " 내 값 다음에 나와 같은 원소는 없다" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:53:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v{1,2,3,4,5,6,6,7,2,3,4 };
	
	auto p = adjacent_find(v.begin(), v.end());

	if (p != v.end())
	{
		cout << "위치 - " << distance(v.begin(), p) +1 << endl;
	}
	else
	{
		cout << "내 값 다음에 나와 같은 원소는 없다" << endl;
	}
	
	save("main.cpp");
}




===============
 Tue May 28 17:58:50 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v;
	for (int i = 0; i < 100; ++i)
	{
		v.emplace_back(i + 1);
	}

	auto p = partition(v.begin(), v.end(), [](int n) {
		return n & 1;
	});

	for (auto iter = v.begin(); iter < p; ++iter)
	{
		cout << *iter << "\t";
	}
	cout << endl;
	for (auto iter = p; iter < v.end(); ++iter)
	{
		cout << *iter << "\t";
	}
	cout << endl;
	
	save("main.cpp");
}




===============
 Tue May 28 18:10:22 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 < s.size();
	});

	//for (auto d : v)
	//{
	//	cout << d << " ";
	//}

	copy(v.begin(), p, ostream_iterator<string>(out));
	
	save("main.cpp");
}




===============
 Tue May 28 18:10:46 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 < s.size();
	});

	//for (auto d : v)
	//{
	//	cout << d << " ";
	//}

	copy(v.begin(), p, ostream_iterator<string>(out," "));
	
	save("main.cpp");
}




===============
 Tue May 28 18:13:36 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 < s.size();
	});

	

	copy(v.begin(), p, ostream_iterator<string>(out," "));

	auto c = partition(v.begin(), v.end(), [](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});


	ofstream ddd("c있는 단어.txt");
	ofstream eee("c없는 단어.txt");
	copy(v.begin(), c, ostream_iterator<string>(ddd, " "));
	copy(c, v.end(), ostream_iterator<string>(eee, " "));
	
	save("main.cpp");
}




===============
 Tue May 28 18:18:51 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 <= s.size();
	});

	copy(v.begin(), p, ostream_iterator<string>(out," "));

	auto c = partition(v.begin(), v.end(), [](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});

	ofstream ddd("c있는 단어.txt");
	ofstream eee("c없는 단어.txt");
	copy(v.begin(), c, ostream_iterator<string>(ddd, " "));
	copy(c, v.end(), ostream_iterator<string>(eee, " "));
	
	save("main.cpp");
}




===============
 Tue May 28 18:21:25 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 <= s.size();
	});

	copy(v.begin(), p, ostream_iterator<string>(out,"\n"));

	auto c = partition(v.begin(), v.end(), [](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});

	ofstream ddd("c있는 단어.txt");
	ofstream eee("c없는 단어.txt");
	copy(v.begin(), c, ostream_iterator<string>(ddd, " "));
	copy(c, v.end(), ostream_iterator<string>(eee, " "));
	
	save("main.cpp");
}




===============
 Tue May 28 18:27:57 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 <= s.size();
	});

	copy(v.begin(), p, ostream_iterator<string>(out,"\n"));

	/*auto c = partition(v.begin(), v.end(), [](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});

	
	copy(v.begin(), c, ostream_iterator<string>(ddd, "\n"));
	copy(c, v.end(), ostream_iterator<string>(eee, "\n"));*/

	ofstream ddd("c있는 단어.txt");
	ofstream eee("c없는 단어.txt");

	partition_copy(istream_iterator<string>(in),istream_iterator<string>(),
		ostream_iterator<string>(ddd,"\n"),
		ostream_iterator<string>(eee,"\n"),
		[](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});
	
	save("main.cpp");
}




===============
 Tue May 28 18:34:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 정렬, 병합
//		sort			- 일반적인 소트 ( n logn )
//		stable_sort		- 원본의 순서를 유지한다
//		partial_sort	- 1등부터 10등까지 정렬
//		nth_element		- 10등까지와 나머지를 구분, 이때 10등까지는 정렬되어 있지 않다.
//						  partial_sort보다 낫다.
//
//		is_sorted		- 정렬된 시퀀스에 적용되는 알고리즘이 있는 데 확인하는 용도
//		merge			- 
//		binary_search	- 정렬되어 있다면 이걸로 존재 유무를 확인한다 
//		equal_range		- 정렬되어 있다면 이걸로 찾아간다.
//
//		
// 검색, 분리
//		find, find_if, find_if_not
//
//		find_first_of   - 두번째 범위의 원소들 중에서 처음 일치하는 것을 범위에서 검색한다
//		adjacent_find	
//
//		find_end
//		search			- 시퀀스에서 서브 시퀀스를 찾는다
//		search_n
//
//		partition		- 조건에 맞는 것과 맞지 않는 것을 분리한다.
//
//     6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>
#include <fstream>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	// 앨리스.txt 파일을 사용하여
	// ( 하드디스크의 파일은 읽기 용도로만 사용하라 )
	// 1. 단어 길이가 10 이상인 단어는 "길이 10이상.txt"에 저장한다
	// 2. c가 들어간 단어와 그렇지 않은 단어를 각각 "c있는 단어.txt" "c없는 단어.txt"에 기록하라

	ifstream in("영문만 남긴 앨리스.txt");
	vector<string> v = { istream_iterator<string>(in),istream_iterator<string>() };

	ofstream out("길이 10이상.txt");

	auto p = partition(v.begin(), v.end(), [](string s) {
		return 10 <= s.size();
	});

	copy(v.begin(), p, ostream_iterator<string>(out,"\n"));

	/*auto c = partition(v.begin(), v.end(), [](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});

	
	copy(v.begin(), c, ostream_iterator<string>(ddd, "\n"));
	copy(c, v.end(), ostream_iterator<string>(eee, "\n"));*/

	ofstream ddd("c있는 단어.txt");
	ofstream eee("c없는 단어.txt");

	partition_copy(istream_iterator<string>(in),istream_iterator<string>(),
		ostream_iterator<string>(ddd,"\n"),
		ostream_iterator<string>(eee,"\n"),
		[](string s) {
		return find(s.begin(), s.end(), 'c') != s.end();
	});
	
	save("main.cpp");
}




===============
 Tue May 28 18:49:32 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


int main()
{
	vector<int> v(1000, 1);

	//v의 모든 원소가 1이니?

	cout << boolalpha << all_of(v.begin(), v.end(), [](int n)
	{
		return n == 1;
	}) << endl;


	
	save("main.cpp");
}




===============
 Tue May 28 18:53:28 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


template<class Iter,class Callable>
bool my_all_of(Iter begin, Iter end, Callable c)
{
	while (begin != end)
	{
		if (c(*begin))
		{
			return false;
		}
	}

	return true;
}
int main()
{
	vector<int> v(1000, 1);

	//v의 모든 원소가 1이니?

	cout << boolalpha << my_all_of(v.begin(), v.end(), [](int n)
	{
		return n == 1;
	}) << endl;


	
	save("main.cpp");
}




===============
 Tue May 28 18:53:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;


template<class Iter,class Callable>
bool my_all_of(Iter begin, Iter end, Callable c)
{
	while (begin != end)
	{
		if (!c(*begin))
		{
			return false;
		}
		++begin;
	}

	return true;
}
int main()
{
	vector<int> v(1000, 1);

	//v의 모든 원소가 1이니?

	cout << boolalpha << my_all_of(v.begin(), v.end(), [](int n)
	{
		return n == 1;
	}) << endl;


	
	save("main.cpp");
}




===============
 Tue May 28 18:59:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
int my_distance(Iter b, Iter e)
{
	return e - b;
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;
	
	save("main.cpp");
}




===============
 Tue May 28 18:59:55 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
int my_distance(Iter b, Iter e)
{
	return e - b;
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.end(), v.begin()) << endl;
	
	save("main.cpp");
}




===============
 Thu May 30 17:37:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	/*int count{ 0 };
	while (b++ != e)
	{
		++count;
	}

	return count;*/

	// 반복자가 랜덤이라면

	if (typeid(Iter) == typeid(random_access_iterator_tag))
		// e-b를 return
	{
		return e - b;
	}
	
	// 그렇지 않다면
	// b부터 e까지 덧셈의 횟수를 계산하여 리턴
	else
	{
		return 1;
	}
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	//list<int> l(1000, 1);
	//cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 17:39:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	/*int count{ 0 };
	while (b++ != e)
	{
		++count;
	}

	return count;*/

	// 반복자가 랜덤이라면
	cout << typeid(Iter).name() << endl;
	cout << typeid(random_access_iterator_tag).name() << endl;
	if (typeid(Iter) == typeid(random_access_iterator_tag))
		// e-b를 return
	{
		return e - b;
	}
	
	// 그렇지 않다면
	// b부터 e까지 덧셈의 횟수를 계산하여 리턴
	else
	{
		return 1;
	}
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	//list<int> l(1000, 1);
	//cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 17:44:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	/*int count{ 0 };
	while (b++ != e)
	{
		++count;
	}

	return count;*/

	// 반복자가 랜덤이라면
	//cout << typeid(typename(Iter::iterator_category)).name() << endl;
	//cout << typeid(random_access_iterator_tag).name() << endl;
	if (typeid(typename Iter::iterator_category) == typeid(random_access_iterator_tag))
		// e-b를 return
	{
		return e - b;
	}
	
	// 그렇지 않다면
	// b부터 e까지 덧셈의 횟수를 계산하여 리턴
	else
	{
		return 1;
	}
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	//list<int> l(1000, 1);
	//cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 17:44:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	/*int count{ 0 };
	while (b++ != e)
	{
		++count;
	}

	return count;*/

	// 반복자가 랜덤이라면
	cout << typeid(typename Iter::iterator_category).name() << endl;
	cout << typeid(random_access_iterator_tag).name() << endl;
	if (typeid(typename Iter::iterator_category) == typeid(random_access_iterator_tag))
		// e-b를 return
	{
		return e - b;
	}
	
	// 그렇지 않다면
	// b부터 e까지 덧셈의 횟수를 계산하여 리턴
	else
	{
		return 1;
	}
}

int main()
{
	vector<int> v(1000, 1);

	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	//list<int> l(1000, 1);
	//cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 17:49:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	// 반복자가 랜덤이라면
	cout << typeid(typename Iter::iterator_category).name() << endl;
	cout << typeid(random_access_iterator_tag).name() << endl;
	//if (typeid(typename Iter::iterator_category) == typeid(random_access_iterator_tag))
		// e-b를 return
	//{
	//	return e - b;
	//}
	// 그렇지 않다면
	// b부터 e까지 덧셈의 횟수를 계산하여 리턴
	
	{
		cout << "랜덤 반복자가 아닙니다" << endl;
		typename Iter::difference_type count{  };
		while (b++ != e)
		{
			count++;
		}
		return count;
	}
}

int main()
{
	//vector<int> v(1000, 1);

	//cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	list<int> l(1000, 1);
	cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 18:00:15 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag);

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	return my_distance(b, e, typename Iter::iterator_category());
}
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag)
{
	return e - b;
}

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag)
{
	int count{ 0 };
	while (b++ != e)
	{
		++count;
	}
	return count;
}

int main()
{
	//vector<int> v(1000, 1);

	//cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	list<int> l(1000, 1);
	cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 18:00:30 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag);

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	return my_distance(b, e, typename Iter::iterator_category());
}
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag)
{
	return e - b;
}

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag)
{
	int count{ 0 };
	while (b++ != e)
	{
		++count;
	}
	return count;
}

int main()
{
	vector<int> v(1000, 1);
	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	list<int> l(1000, 1);
	cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 18:02:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iterator>

#include "Save.h"
#include "String.h"

using namespace std;

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag);
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag);

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e)
{
	return my_distance(b, e, typename Iter::iterator_category());
}
template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, random_access_iterator_tag)
{
	return e - b;
}

template < class Iter>
typename Iter::difference_type my_distance(Iter b, Iter e, forward_iterator_tag)
{
	typename Iter::difference_type count{ 0 };
	while (b++ != e)
	{
		++count;
	}
	return count;
}

int main()
{
	vector<int> v(1000, 1);
	cout << "v의 원소 갯수 - " << my_distance(v.begin(), v.end()) << endl;

	list<int> l(1000, 1);
	cout << "l의 원소 갯수 - " << my_distance(l.begin(), l.end()) << endl;

	
	save("main.cpp");
}




===============
 Thu May 30 18:31:39 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

int main()
{
	/*ifstream in("단어들.txt");
	set<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	string findname;
	while (true)
	{
		cout << "단어를 입력하세요:";
		cin >> findname;
		system("cls");
		auto p = s.find(findname);
		set <string> findedstring;
		if (p != s.end())
		{
			cout << findname << "은 있습니다" << endl;
			findedstring.clear();
			for (int i = 0; i < findname.size(); ++i)
			{
				for (int j = i+1; j < findname.size(); ++j)
				{
					string tempstring = findname;
					char a = tempstring[i];
					tempstring[i] = tempstring[j];
					tempstring[j] = a;
					auto pp = s.find(tempstring);
					if (pp != s.end() && findedstring.find(*pp) != findedstring.end())
					{
						cout << "애너그램:" << *pp << endl;
						findedstring.emplace(*pp);
					}
				}
			}
		}
		else
		{
			cout << "찾으시는 단어가 없습니다" << endl;
		}

	}
*/
	

	vector<int> v{ 1,2,3 };
	vector<int> vc{ v };
	do
	{
		for (int d : vc)
		{
			cout << d << endl;
		}
		next_permutation(vc.begin(), vc.end());
	} while (v != vc);
	
	save("main.cpp");
}




===============
 Thu May 30 18:31:58 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

int main()
{
	/*ifstream in("단어들.txt");
	set<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	string findname;
	while (true)
	{
		cout << "단어를 입력하세요:";
		cin >> findname;
		system("cls");
		auto p = s.find(findname);
		set <string> findedstring;
		if (p != s.end())
		{
			cout << findname << "은 있습니다" << endl;
			findedstring.clear();
			for (int i = 0; i < findname.size(); ++i)
			{
				for (int j = i+1; j < findname.size(); ++j)
				{
					string tempstring = findname;
					char a = tempstring[i];
					tempstring[i] = tempstring[j];
					tempstring[j] = a;
					auto pp = s.find(tempstring);
					if (pp != s.end() && findedstring.find(*pp) != findedstring.end())
					{
						cout << "애너그램:" << *pp << endl;
						findedstring.emplace(*pp);
					}
				}
			}
		}
		else
		{
			cout << "찾으시는 단어가 없습니다" << endl;
		}

	}
*/
	

	vector<int> v{ 1,2,3 };
	vector<int> vc{ v };
	do
	{
		for (int d : vc)
		{
			cout << d << " ";
		}
		cout << endl;
		next_permutation(vc.begin(), vc.end());
	} while (v != vc);
	
	save("main.cpp");
}




===============
 Thu May 30 18:32:09 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

int main()
{
	/*ifstream in("단어들.txt");
	set<string> s{ istream_iterator<string>(in),istream_iterator<string>() };
	string findname;
	while (true)
	{
		cout << "단어를 입력하세요:";
		cin >> findname;
		system("cls");
		auto p = s.find(findname);
		set <string> findedstring;
		if (p != s.end())
		{
			cout << findname << "은 있습니다" << endl;
			findedstring.clear();
			for (int i = 0; i < findname.size(); ++i)
			{
				for (int j = i+1; j < findname.size(); ++j)
				{
					string tempstring = findname;
					char a = tempstring[i];
					tempstring[i] = tempstring[j];
					tempstring[j] = a;
					auto pp = s.find(tempstring);
					if (pp != s.end() && findedstring.find(*pp) != findedstring.end())
					{
						cout << "애너그램:" << *pp << endl;
						findedstring.emplace(*pp);
					}
				}
			}
		}
		else
		{
			cout << "찾으시는 단어가 없습니다" << endl;
		}

	}
*/
	

	vector<int> v{ 1,2,3,4,5,6 };
	vector<int> vc{ v };
	do
	{
		for (int d : vc)
		{
			cout << d << " ";
		}
		cout << endl;
		next_permutation(vc.begin(), vc.end());
	} while (v != vc);
	
	save("main.cpp");
}




===============
 Tue Jun  4 17:38:56 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

int main()
{
	ifstream in("단어들.txt");
	vector<string> v{ istream_iterator<string>(in),istream_iterator<string>() };
	
	vector<pair<string, string>> vs;
	
	for (int i = 0; i < v.size(); ++i)
	{
		vs.push_back({ v[i], v[i] });
		sort(vs[i].first.begin(), vs[i].first.end());
	}

	for (int i = 10'0000; i < 10'0200; ++i)
	{
		cout << vs[i].first << " " << vs[i].second << endl;
	}
	

	save("main.cpp");
}




===============
 Tue Jun  4 17:40:52 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

int main()
{
	ifstream in("단어들.txt");
	vector<string> v{ istream_iterator<string>(in),istream_iterator<string>() };
	
	vector<pair<string, string>> vs;
	
	for (int i = 0; i < v.size(); ++i)
	{
		vs.push_back({ v[i], v[i] });
		sort(vs[i].first.begin(), vs[i].first.end());
	}

//first 기준으로 vs를 정렬
	sort(vs.begin(), vs.end(), [](const pair<string,string>& a, const pair<string,string>& b) {
		return a.first < b.first;
	});


	for (int i = 10'0000; i < 10'0200; ++i)
	{
		cout << vs[i].first << " " << vs[i].second << endl;
	}
	

	save("main.cpp");
}




===============
 Tue Jun  4 18:37:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	




	save("main.cpp");
}




===============
 Tue Jun  4 18:37:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	


//first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});




	save("main.cpp");
}




===============
 Tue Jun 11 17:53:27 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	auto b = adjacent_find(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first == b.first;
	});

	auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
	{
		return a.first != b->first;
	});

	//[b,e]는 애너그램 구간이다
	cout << "애너그램쌍 - ";
	for (auto i = b; i != e; ++i)
	{
		cout << i->second << " ";
	}
	cout << endl;

	save("main.cpp");
}




===============
 Tue Jun 11 17:53:35 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	auto b = adjacent_find(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first == b.first;
	});

	auto e = find_if_not(b, v.end(), [b](const PS& a)
	{
		return a.first != b->first;
	});

	//[b,e]는 애너그램 구간이다
	cout << "애너그램쌍 - ";
	for (auto i = b; i != e; ++i)
	{
		cout << i->second << " ";
	}
	cout << endl;

	save("main.cpp");
}




===============
 Tue Jun 11 17:54:00 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	auto b = adjacent_find(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first == b.first;
	});

	auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
	{
		return a.first == b->first;
	});

	//[b,e]는 애너그램 구간이다
	cout << "애너그램쌍 - ";
	for (auto i = b; i != e; ++i)
	{
		cout << i->second << " ";
	}
	cout << endl;

	save("main.cpp");
}




===============
 Tue Jun 11 18:01:03 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	auto a = v.begin();
	for (; a != v.end();)
	{
		
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		a = e;

		//[b,e]는 애너그램 구간이다
		cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			cout << i->second << " ";
		}
		cout << endl;
		
	}

	save("main.cpp");
}




===============
 Tue Jun 11 18:05:14 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	auto a = v.begin();
	for (;;)
	{
		
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			cout << i->second << " ";
		}
		cout << endl;
		a = e;
	}

	save("main.cpp");
}




===============
 Tue Jun 11 18:11:42 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			cout << i->second << " ";
			cout << i->second << " ";
		}
		cout << endl;
		cout << endl;
		a = e;
	}

	save("main.cpp");
}




===============
 Tue Jun 11 18:12:05 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			cout << i->second << " ";
			cout << i->second << " ";
		}
		cout << endl;
		out << endl;
		a = e;
	}

	save("main.cpp");
}




===============
 Tue Jun 11 18:12:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;

// "단어들.txt" 파일에 있는 단어를 컨테이너에 읽어오자
//
// 사용자가 찾을 단어를 입력하게 하자
// 1.단어가 있다면 사전에 그 단어가 있다고 알려주자
//    그 단어의 anagram을 모두 찾아 화면에 출력하자
// 2.없다면 "그런 단어는 없습니다"라고 출력하자

struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});

	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			cout << i->second << " ";
			out << i->second << " ";
		}
		cout << endl;
		out << endl;
		a = e;
	}

	save("main.cpp");
}




===============
 Tue Jun 11 18:27:38 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		//cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			//cout << i->second << " ";
			out << i->second << " ";
		}
		//cout << endl;
		out << endl;
		a = e;
	}

	ifstream ina("애너그램쌍");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});

	for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:27:49 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		//cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			//cout << i->second << " ";
			out << i->second << " ";
		}
		//cout << endl;
		out << endl;
		a = e;
	}

	ifstream ina("애너그램쌍");
	string input;
	vector<string> vs;
	while (!(in.eof()))
	{
		getline(ina, input);
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});

	for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:28:18 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		//cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			//cout << i->second << " ";
			out << i->second << " ";
		}
		//cout << endl;
		out << endl;
		a = e;
	}

	ifstream ina("애너그램쌍");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";
	for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:28:40 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		//cout << "애너그램쌍 - ";
		for (auto i = b; i != e; ++i)
		{
			//cout << i->second << " ";
			out << i->second << " ";
		}
		//cout << endl;
		out << endl;
		a = e;
	}

	ifstream ina("애너그램쌍");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		vs.push_back(input);
	}
	for (auto d : vs)
	{
		cout << d << endl;
	}
	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";

	save("main.cpp");
}




===============
 Tue Jun 11 18:29:07 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("애너그램쌍");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		cout << input;
		vs.push_back(input);
	}
	for (auto d : vs)
	{
		cout << d << endl;
	}
	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";

	save("main.cpp");
}




===============
 Tue Jun 11 18:29:37 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		cout << input;
		vs.push_back(input);
	}
	for (auto d : vs)
	{
		cout << d << endl;
	}
	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";

	save("main.cpp");
}




===============
 Tue Jun 11 18:30:08 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (!in.eof())
	{
		getline(ina, input);
		//cout << input;
		vs.push_back(input);
	}
	for (auto d : vs)
	{
		cout << d << endl;
	}
	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";

	save("main.cpp");
}




===============
 Tue Jun 11 18:30:20 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (!(in.eof()))
	{
		getline(ina, input);
		//cout << input;
		vs.push_back(input);
	}
	for (auto d : vs)
	{
		cout << d << endl;
	}
	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";

	save("main.cpp");
}




===============
 Tue Jun 11 18:31:29 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (getline(ina, input))
	{
		
		//cout << input;
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";
	for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:32:10 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (getline(ina, input))
	{
		
		//cout << input;
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return a.length() < b.length();
	});
	cout << "dsadsad";
	for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:37:12 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (getline(ina, input))
	{
		
		//cout << input;
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return count(a.begin(), a.end(), ' ') < count(b.begin(), b.end(), ' ');
	});
	cout << "dsadsad";
		for (auto d : vs)
	{
		cout << d << endl;
	}
	save("main.cpp");
}




===============
 Tue Jun 11 18:39:25 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (getline(ina, input))
	{
		
		//cout << input;
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return count(a.begin(), a.end(), ' ') < count(b.begin(), b.end(), ' ');
	});
	ofstream ddddddd("애너그램 갯수 내림차순") ;
	for (auto d : vs)
	{
		cout << d << endl;;
		ddddddd << d << endl;
	}

		
	save("main.cpp");
}




===============
 Tue Jun 11 18:46:18 2019
===============
///////////////////////////////////////////////////////////////////////
// 2019 STL 
//
// 7장 다양한 알고리즘
//
// 6월 13일 기만고사		
/////////////////////////////////////////////////////////////////////// 

#include <iostream>
#include <fstream>
#include <set>
#include <iterator>
#include <algorithm>
#include <vector>

#include "Save.h"
#include "String.h"

using namespace std;


struct PS : public pair<string, string>
{
	PS(string s) : pair(s, s)
	{
		sort(first.begin(), first.end());
	}
};



int main()
{
	ifstream in("단어들.txt");
	vector<PS> v{ istream_iterator<string>(in),istream_iterator<string>() };
	cout << "단어를 읽어 쌍으로 만들었습니다." << endl;
	
	// first 기준으로 vs를 정렬
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
	});


	
	// 문제: 모든 애너그램 쌍을 "애너그램들.txt"에 기록하라

	ofstream out("단어쌍이다");
	auto a = v.begin();
	for (;;)
	{
		auto b = adjacent_find(a, v.end(), [](const PS& a, const PS& b) {
			return a.first == b.first;
		});

		if (b == v.end())
		{
			break;
		}

		auto e = find_if_not(b + 1, v.end(), [b](const PS& a)
		{
			return a.first == b->first;
		});
		
		

		//[b,e]는 애너그램 구간이다
		
		for (auto i = b; i != e; ++i)
		{
			
			out << i->second << " ";
		}
		
		out << endl;
		a = e;
	}

	ifstream ina("단어쌍이다");
	string input;
	vector<string> vs;
	while (getline(ina, input))
	{
		
		//cout << input;
		vs.push_back(input);
	}

	sort(vs.begin(), vs.end(), [](string& a, string& b)
	{
		return count(a.begin(), a.end(), ' ') > count(b.begin(), b.end(), ' ');
	});
	ofstream ddddddd("애너그램 갯수 내림차순") ;
	for (auto d : vs)
	{
		cout << d << endl;;
		ddddddd << d << endl;
	}

		
	save("main.cpp");
}


